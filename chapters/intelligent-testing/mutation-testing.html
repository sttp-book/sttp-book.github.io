
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Mutation testing Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-hints/plugin-hints.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="fuzzing.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../preface/authors.html">
            
                <a href="../preface/authors.html">
            
                    
                    Authors
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../preface/acknowledgments.html">
            
                <a href="../preface/acknowledgments.html">
            
                    
                    Acknowledgments
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../preface/adopt.html">
            
                <a href="../preface/adopt.html">
            
                    
                    Adopt this book
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../preface/contribute.html">
            
                <a href="../preface/contribute.html">
            
                    
                    Contribute to this book
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../preface/license.html">
            
                <a href="../preface/license.html">
            
                    
                    License
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../getting-started/">
            
                <a href="../getting-started/">
            
                    
                    Getting started with software testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="../getting-started/why-software-testing.html">
            
                <a href="../getting-started/why-software-testing.html">
            
                    
                    Why software testing?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="../getting-started/testing-principles.html">
            
                <a href="../getting-started/testing-principles.html">
            
                    
                    Principles of software testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.3" data-path="../getting-started/test-automation.html">
            
                <a href="../getting-started/test-automation.html">
            
                    
                    Software testing automation
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../testing-techniques/">
            
                <a href="../testing-techniques/">
            
                    
                    Testing techniques
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1.1" data-path="../testing-techniques/specification-based-testing.html">
            
                <a href="../testing-techniques/specification-based-testing.html">
            
                    
                    Specification-based testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.2" data-path="../testing-techniques/boundary-testing.html">
            
                <a href="../testing-techniques/boundary-testing.html">
            
                    
                    Boundary testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.3" data-path="../testing-techniques/structural-testing.html">
            
                <a href="../testing-techniques/structural-testing.html">
            
                    
                    Structural-based testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.4" data-path="../testing-techniques/model-based-testing.html">
            
                <a href="../testing-techniques/model-based-testing.html">
            
                    
                    Model-based testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.5" data-path="../testing-techniques/design-by-contracts.html">
            
                <a href="../testing-techniques/design-by-contracts.html">
            
                    
                    Design-by-contracts and property-based testing
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../pragmatic-testing/">
            
                <a href="../pragmatic-testing/">
            
                    
                    Pragmatic software testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1" data-path="../pragmatic-testing/testing-pyramid.html">
            
                <a href="../pragmatic-testing/testing-pyramid.html">
            
                    
                    The testing pyramid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.2" data-path="../pragmatic-testing/mocking.html">
            
                <a href="../pragmatic-testing/mocking.html">
            
                    
                    Mock objects
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3" data-path="../pragmatic-testing/design-for-testability.html">
            
                <a href="../pragmatic-testing/design-for-testability.html">
            
                    
                    Design for testability
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4" data-path="../pragmatic-testing/tdd.html">
            
                <a href="../pragmatic-testing/tdd.html">
            
                    
                    Test-driven development
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.5" data-path="../pragmatic-testing/test-code-quality.html">
            
                <a href="../pragmatic-testing/test-code-quality.html">
            
                    
                    Test code quality
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="./">
            
                <a href="./">
            
                    
                    Intelligent testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="5.1.1" data-path="mutation-testing.html">
            
                <a href="mutation-testing.html">
            
                    
                    Mutation testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.2" data-path="fuzzing.html">
            
                <a href="fuzzing.html">
            
                    
                    Fuzzing testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.3" >
            
                <span>
            
                    
                    Search-based software testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="6.1" data-path="../testing-into-context/">
            
                <a href="../testing-into-context/">
            
                    
                    Testing in the context
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="6.1.1" >
            
                <span>
            
                    
                    Web testing (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.2" >
            
                <span>
            
                    
                    Database testing (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.3" >
            
                <span>
            
                    
                    Mobile testing (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.4" >
            
                <span>
            
                    
                    Continuous experimentation (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.5" >
            
                <span>
            
                    
                    Embedded software testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="7.1" data-path="../non-functional-testing/README.md">
            
                <span>
            
                    
                    Non-functional testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="7.1.1" >
            
                <span>
            
                    
                    Security testing (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="7.1.2" >
            
                <span>
            
                    
                    Performance testing (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="7.1.3" >
            
                <span>
            
                    
                    Ethical testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="8.1" >
            
                <span>
            
                    
                    Appendix
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="8.1.1" data-path="../appendix/answers.html">
            
                <a href="../appendix/answers.html">
            
                    
                    Answers to the exercises
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.1.2" data-path="../appendix/changelog.html">
            
                <a href="../appendix/changelog.html">
            
                    
                    Change log
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Mutation testing</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="mutation-testing">Mutation testing</h1>
<p>How do we know if we tested enough?
For example, in the structural-based testing chapter, we discussed line coverage, branch coverage, and MC/DC.
In the model-based testing chapter, we discussing transition coverage and path coverage.
All these <strong>adequacy criteria</strong> measure how much of the program is exercised 
by the tests we devised.</p>
<p>However, these criteria alone might not enough to determine the 
quality of the test cases.
In practice, we can exercise a large part of the system, while testing very little.</p>
<p>Suppose a simple class with a single method:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Division</span> </span>{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getValues(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
    <span class="hljs-keyword">int</span> quotient = a / b;
    <span class="hljs-keyword">int</span> remainder = a % b;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {quotient, remainder};
  }
}
</code></pre>
<p>Now, imagine a tester writing the following test cases:</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetValues</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span>[] values = Division.getValues(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testZero</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span>[] values = Division.getValues(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
}
</code></pre>
<p>These tests gets us to 100% branch coverage.
However, you probably also noticed that something is missing in these tests: 
<strong>the assertions</strong>! These tests will never fail!</p>
<h2 id="fault-detection-capability">Fault Detection Capability</h2>
<p>Let&apos;s discuss one more adequacy criterion: the <strong>fault detection capability</strong>.
It indicates the test&apos;s capability to reveal faults in the system under test.
The more faults a test can detect, in other words, the more faults a test fails on, the higher its fault detection capability.
Using this criterion, we can indicate the quality of our test suite in a better way than with just the coverage metrics we have so far.</p>
<p>The fault detection capability does not just regard the amount of production code executed, but also the assertions made in the test cases.
For a test to be adequate according to this criterion, it has to have a meaningful <strong>test oracle</strong> (i.e., meaningful assertions).</p>
<p>The fault detection capability, as a test adequacy criterion, is the fundamental idea behind <strong>mutation testing</strong>.
In mutation testing, we change small parts of the code, and check if the tests can find the introduced fault.</p>
<p>In the previous example, we made a test suite that was not adequate at all, according to the fault detection capability.
As there were no assertions, the tests would never find any faults in the code.</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetValues</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span>[] values = Division.getValues(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  assertEquals(<span class="hljs-number">1</span>, values[<span class="hljs-number">0</span>]);
  assertEquals(<span class="hljs-number">0</span>, values[<span class="hljs-number">1</span>]);
}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testZero</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span>[] values = Division.getValues(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
  assertNull(values);
}
</code></pre>
<p>Tests with assertions check if the result of the method is what we expect. We have a <strong>test oracle</strong> now.</p>
<p>To see how the values in a test case influence the fault detection capability, let&apos;s create two tests, where the denominator is not 0.</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetValuesOnes</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span>[] values = Division.getValues(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  assertEquals(<span class="hljs-number">1</span>, values[<span class="hljs-number">0</span>]);
  assertEquals(<span class="hljs-number">0</span>, values[<span class="hljs-number">1</span>]);
}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetValuesDifferent</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span>[] values = Division.getValues(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);
  assertEquals(<span class="hljs-number">1</span>, values[<span class="hljs-number">0</span>]);
  assertEquals(<span class="hljs-number">1</span>, values[<span class="hljs-number">1</span>]);
}
</code></pre>
<p>For the fault detection capability, we want to see if the tests catch any faults that could be in the code.</p>
<p>This means we have to go back to the source code and introduce an error:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Division</span> </span>{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getValues(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
    <span class="hljs-keyword">int</span> quotient = a * b; <span class="hljs-comment">// the bug was introduced here</span>
    <span class="hljs-keyword">int</span> remainder = a % b;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {quotient, remainder};
  }
}
</code></pre>
<p>We replace the division by a multiplication; a clear bug.</p>
<p>If we run our tests with the buggy code, we see that the test with the values 1 and 1 (the <code>testGetValuesOnes()</code> test) still passes, but the other test (the <code>testGetValuesDifferent()</code>) fails.
This indicates that the second test has a higher fault detection capability.</p>
<p>Even though both tests exercise the method in the same way and execute the same lines, we see a difference in the fault detection capability.
This is because of the different input values for the method and the different test oracles (assertions) in the tests.
In this case, the input values and test oracle of the <code>testGetValuesDifferent()</code> test can better detect that bug.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/QYbqz-gFWAk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>



<h2 id="hypotheses-for-mutation-testing">Hypotheses for Mutation Testing</h2>
<p>We are now ready to generalize the idea.
The idea of mutation testing is to <strong>assess the quality of the test suite</strong>.
This is done by manipulating the source code a bit and running the tests with this manipulated source code.
If we have a good test suite, at least one of the tests will fail on this changed (buggy) code.
Following this procedure, we get a sense of the fault error capability of our test suite.</p>
<p>In mutation testing we use <strong>mutants</strong>.
The mutants are the defects, or faults, that we introduce in the source code and then use to determine the quality of the test suite.</p>
<p>A big question regarding the mutants is what their size should be.
We can change single operations, whole lines or even multiple lines of code.
What would work best?</p>
<p>Mutation testing and the answer to this question are based on the following two hypotheses:</p>
<ul>
<li><p><strong>The Competent Programmar Hypothesis (CPH)</strong>:
Here, we assume that the program is written by a competent programmer.
More importantly, this means that given a certain specification, the programmer creates a program that is either correct, or it differs from a correct program by a combination of simple errors.</p>
</li>
<li><p><strong>The Coupling Effect</strong>:
The coupling effect hypothesis states that simple faults are coupled to more complex faults.
In other words, test cases that detect simple faults, will also detect complex faults.</p>
</li>
</ul>
<p>Based on these two hypotheses, we can determine the size 
that the mutants should have.
Realistically, following the competent programmer hypothesis, 
the faults in actual code will be small.
This indicates that the mutants&apos; size should be small as well.
Considering the coupling effect, test cases that detect 
small errors, will also be able to detect larger, more complex errors.</p>
<h2 id="terminology">Terminology</h2>
<p>To talk about mutation testing in a depth way, let&apos;s define some terms:</p>
<ul>
<li><strong>Mutant</strong>: Given a program <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span>, a mutant called <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mrow><mi mathvariant="normal">&#x2032;</mi></mrow></msup></mrow><annotation encoding="application/x-tex">P&apos;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">&#x2032;</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> is obtained by introducing a <em>syntactic change</em> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span>. A mutant is killed if a test fails when executed with the mutant.</li>
<li><strong>Syntactic Change</strong>: A small <em>change</em> in the code. Such a small change should make the code still valid, i.e., the code can still compile and run.</li>
<li><strong>Change</strong>: A change, or alternation, to the code that mimic typical human mistakes. We will see some examples of these mistakes later.</li>
</ul>
<p>We illustrate mutation testing with these concepts in the example below.</p>
<p>Suppose we have a <code>Fraction</code> class with a method <code>invert()</code>.</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numerator;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> denominator;

  <span class="hljs-comment">// ...</span>

  <span class="hljs-function"><span class="hljs-keyword">public</span> Fraction <span class="hljs-title">invert</span><span class="hljs-params">()</span> </span>{
<span class="hljs-number">1</span>.  <span class="hljs-keyword">if</span> (numerator == <span class="hljs-number">0</span>) {
<span class="hljs-number">2</span>.    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException(<span class="hljs-string">&quot;...&quot;</span>);
    }
<span class="hljs-number">3</span>.  <span class="hljs-keyword">if</span> (numerator == Integer.MIN_VALUE) {
<span class="hljs-number">4</span>.    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException(<span class="hljs-string">&quot;...&quot;</span>);
    }
<span class="hljs-number">5</span>.  <span class="hljs-keyword">if</span> (numerator &lt; <span class="hljs-number">0</span>) {
<span class="hljs-number">6</span>.    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fraction(-denominator, -numerator);
    }
<span class="hljs-number">7</span>.  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fraction(denominator, numerator);
  }
}
</code></pre>
<p>We have a small test suite for this method as well.</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInvert</span><span class="hljs-params">()</span></span>{
  Fraction f = <span class="hljs-keyword">new</span> Fraction(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
  Fraction result = f.invert();
  assertEquals(<span class="hljs-number">2</span>, result.getFloat(), <span class="hljs-number">0.00001</span>);
}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInvertNegative</span><span class="hljs-params">()</span></span>{
  Fraction f = <span class="hljs-keyword">new</span> Fraction(-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
  Fraction result = f.invert();
  assertEquals(-<span class="hljs-number">2</span>, result.getFloat(), <span class="hljs-number">0.00001</span>);
}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInvertZero</span><span class="hljs-params">()</span></span>{
  Fraction f = <span class="hljs-keyword">new</span> Fraction(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);
  assertThrows(ArithmeticException.class, () -&gt; f.invert());
}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInvertMinValue</span><span class="hljs-params">()</span></span>{
  <span class="hljs-keyword">int</span> n = Integer.MIN_VALUE;
  Fraction f = <span class="hljs-keyword">new</span> Fraction(n, <span class="hljs-number">2</span>);
  assertThrows(ArithmeticException.class, () -&gt; f.invert());
}
</code></pre>
<p>We have two tests for some corner cases that throw an exception, and two more &quot;happy path&quot; tests.
Now, we want to determine the quality of our test suite, using mutation testing.</p>
<p>First, we have to create a <em>mutant</em> by applying a <em>syntactic change</em> to the original method.
Keep in mind that, because of the two hypotheses, we want the syntactic change to be small: one operation/variable should be enough.
Moreover, the syntactic change is a <em>change</em>, hence it should mimic mistakes that could be made by a programmer.</p>
<p>For the first mutant we change line 6.
Instead of <code>-numerator</code> we just say <code>numerator</code>.</p>
<p>The mutant looks like as follows:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numerator;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> denominator;

  <span class="hljs-comment">// ...</span>

  <span class="hljs-function"><span class="hljs-keyword">public</span> Fraction <span class="hljs-title">invert</span><span class="hljs-params">()</span> </span>{
<span class="hljs-number">1</span>.  <span class="hljs-keyword">if</span> (numerator == <span class="hljs-number">0</span>) {
<span class="hljs-number">2</span>.    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException(<span class="hljs-string">&quot;...&quot;</span>);
    }
<span class="hljs-number">3</span>.  <span class="hljs-keyword">if</span> (numerator == Integer.MIN_VALUE) {
<span class="hljs-number">4</span>.    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException(<span class="hljs-string">&quot;...&quot;</span>);
    }
<span class="hljs-number">5</span>.  <span class="hljs-keyword">if</span> (numerator &lt; <span class="hljs-number">0</span>) {
<span class="hljs-number">6</span>.    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fraction(-denominator, numerator);
    }
<span class="hljs-number">7</span>.  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fraction(denominator, numerator);
  }
}
</code></pre>
<p>If we would execute the test suite on this mutant, the <code>testInvertNegative()</code> test will fail, as <code>result.getFloat()</code> would be positive instead of negative.</p>
<p>Another mistake could be made in line 1.
When we studied boundary analysis, we saw that it is important to test the boundaries due to off-by-one errors.
We can make a syntactic change by introducing such an off-by-on error.
Instead of <code>numerator == 0</code>, in our new mutant we make it <code>numerator == 1</code>:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numerator;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> denominator;

  <span class="hljs-comment">// ...</span>

  <span class="hljs-function"><span class="hljs-keyword">public</span> Fraction <span class="hljs-title">invert</span><span class="hljs-params">()</span> </span>{
<span class="hljs-number">1</span>.  <span class="hljs-keyword">if</span> (numerator == <span class="hljs-number">1</span>) {
<span class="hljs-number">2</span>.    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException(<span class="hljs-string">&quot;...&quot;</span>);
    }
<span class="hljs-number">3</span>.  <span class="hljs-keyword">if</span> (numerator == Integer.MIN_VALUE) {
<span class="hljs-number">4</span>.    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException(<span class="hljs-string">&quot;...&quot;</span>);
    }
<span class="hljs-number">5</span>.  <span class="hljs-keyword">if</span> (numerator &lt; <span class="hljs-number">0</span>) {
<span class="hljs-number">6</span>.    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fraction(-denominator, numerator);
    }
<span class="hljs-number">7</span>.  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fraction(denominator, numerator);
  }
}
</code></pre>
<p>We see that, again, the test suite catches this error.
The test <code>testInvertZero()</code> will fail, as it expects an exception, but none is thrown in the mutant.</p>
<h2 id="automation">Automation</h2>
<p>Manually writing the mutations of our programs takes a lot of time, 
and we probably would only think of the cases that are already tested.
Like with test execution, we want to <strong>automate the mutation process</strong>.
There are various tools that automatically generate mutants for mutant testing, but they all use the same methodology.</p>
<p>First we need mutation operators.
A <strong>mutation operator</strong> is a grammatic rule that can be used to introduce a syntactic change.
This means that, if the generator sees a statement in the code that corresponds to the grammatic rule of the operator (e.g., <code>a + b</code>), then the mutation operator specifies how to change this statement with a syntactic change (e.g., turning it into <code>a - b</code> for example).</p>
<p>We distinguish two categories of mutation operators:</p>
<ul>
<li><strong>Real fault based operators</strong>: Operators that are very similar to defects seen in the past for the same kind of code. Such operators look like common mistakes made by programmers in similar code.</li>
<li><strong>Language-specific operators</strong>: Mutations that are made specifically for a certain programming language. For example, changes related to the inheritance feature we have in the Java language, or changes regarding pointer manipulations in C, which we cannot simply apply to all the languages.</li>
</ul>
<p>Most mutation testing tools include various basic mutation operators for real fault based operators.
We briefly go over some common mutation operators:</p>
<ul>
<li><strong>AOR - Arithmetic Operator Replacement</strong>: Replaces an arithmetic operator by another arithmetic operator. Arithmetic operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>.</li>
<li><strong>ROR - Relational Operator Replacement</strong>: Replaces a relational operator by another relational operator. Relational operators are <code>&lt;=</code>, <code>&gt;=</code>, <code>!=</code>, <code>==</code>, <code>&gt;</code>, <code>&lt;</code>.</li>
<li><strong>COR - Conditional Operator Replacement</strong>: Replaces a conditional operator by another conditional operator. Conditional operators are <code>&amp;&amp;</code>, <code>||</code>, <code>&amp;</code>, <code>|</code>, <code>!</code>, <code>^</code>.</li>
<li><strong>AOR - Assignment Operator Replacement</strong>: Replaces an assignment operator by another assignment operator. Assignment operators include <code>=</code>, <code>+=</code>, <code>-=</code>, <code>/=</code>.</li>
<li><strong>SVR - Scalar Variable Replacement</strong>: Replaces each variable reference by another variable reference that has been declared in the code.</li>
</ul>
<p>For each of the mutation operators, we provide an example.
We first show the original code, and then the mutant that could be given by the mutant operator.</p>
<p><strong>Arithmetic Operator Replacement</strong></p>
<p>Original:</p>
<pre><code class="lang-java"><span class="hljs-keyword">int</span> c = a + b;
</code></pre>
<p>Example of a mutant:</p>
<pre><code class="lang-java"><span class="hljs-keyword">int</span> c = a - b;
</code></pre>
<p><strong>Relational Operator Replacement</strong></p>
<p>Original:</p>
<pre><code class="lang-java"><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) {
  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre>
<p>Example of a mutant:</p>
<pre><code class="lang-java"><span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>) {
  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre>
<p><strong>Conditional Operator Replacement</strong></p>
<p>Original:</p>
<pre><code class="lang-java"><span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> || a.length == <span class="hljs-number">0</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
}
</code></pre>
<p>Example of a mutant:</p>
<pre><code class="lang-java"><span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> | a.length == <span class="hljs-number">0</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
}
</code></pre>
<p><strong>Assignment Operator Replacement</strong></p>
<p>Original:</p>
<pre><code class="lang-java">c = a + b;
</code></pre>
<p>Example of a mutant:</p>
<pre><code class="lang-java">c -= a + b;
</code></pre>
<p><strong>Scalar Variable Replacement</strong></p>
<p>Original:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Division</span> </span>{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getValues(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span> || b == Integer.MIN_VALUE){
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-keyword">int</span> quotient = a / b;
    <span class="hljs-keyword">int</span> remainder = a % b;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {quotient, remainder};
  }
}
</code></pre>
<p>Example of a mutant:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Division</span> </span>{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getValues(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span> || a == Integer.MIN_VALUE){
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-keyword">int</span> quotient = b / a;
    <span class="hljs-keyword">int</span> remainder = quotient % a;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {remainder, a};
  }
}
</code></pre>
<p>Specifically to Java, there are a lot of language-specific operators.
We can, for example, change the inheritance of the class, remove an overriding method, or change some declaration types.
We will not go into detail about these language-specific mutant operators, but some examples are:</p>
<ul>
<li>Access Modifier Change</li>
<li>Hiding Variable Deletion</li>
<li>Hiding Variable Insertion</li>
<li>Overriding Method Deletion</li>
<li>Parent Constructor Deletion</li>
<li>Declaration Type Change</li>
</ul>
<p>Of course, there exist many more mutant operators that are used by mutant generators.
For now, you should at least have an idea what mutation operators are, how they work and what we can use them for.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/KXQTWLyR5CA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


<h2 id="mutation-analysis-and-testing">Mutation Analysis and Testing</h2>
<p>Now that the concept of mutation testing and how to make it is clear,
let&apos;s look at how we can use mutation testing in practice.</p>
<p>Our goal is to use mutation testing to determine the quality of our test suite.
We have seen that we first have to create the mutants and that it is best to do this in an automated way with the help of mutant operators.
Then, we run the test suite against the created mutants with an execution engine.
If one of the tests fails, we say that the test suite kills the mutant.
This is good, as it suggests that our test suite has some fault detection capability.
If none of the tests in our test suite fails when executed against the mutant, this mutant stays alive.</p>
<p>This process is illustrated in the diagram below:</p>
<p><img src="img/mutation-testing/mutation_analysis_process.png" alt="Mutation Testing Process"></p>
<p>When performing mutation testing, we count the number of mutants our test suite killed and the number of mutants that were still alive.
By counting the amount of each of these mutant groups, we can give a value to the quality of our test suite.\
We define the <strong>Mutation Score</strong> as:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">M</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mtext>&#xA0;</mtext><mi mathvariant="normal">s</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mtext>&#xA0;</mtext></mtext><mo>=</mo><mfrac><mrow><mtext><mi mathvariant="normal">k</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mtext>&#xA0;</mtext><mi mathvariant="normal">m</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">s</mi></mtext></mrow><mrow><mtext><mi mathvariant="normal">m</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">s</mi></mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{Mutation score } = \frac{\text{killed mutants}}{\text{mutants}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">Mutation&#xA0;score&#xA0;</span></span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord text scriptstyle cramped mtight"><span class="mord mathrm mtight">mutants</span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord text scriptstyle uncramped mtight"><span class="mord mathrm mtight">killed&#xA0;mutants</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></p>
<p>Computing this mutation score is what we call <strong>mutation analysis</strong>.
More formally:\
<strong>Mutation analysis</strong> means assessing the quality of a test suite, by computing its mutation score.</p>
<p>When the mutation score is low, we might want to change or add new test cases in our test suite.
This is called <strong>mutation testing</strong>.
Again, the definition:
<strong>Mutation testing</strong> means improving the quality of the test suite using mutants (by adding and/or changing test cases).</p>
<p>These concepts are very related to each other.
To do mutation testing, you have to compute the mutation score first.
This then indicates whether the test suite should be changed.
If the mutation score is low, there are a lot of mutants that are not killed by the test suite.
Then, it is indeed our job to improve the test suite.</p>
<h3 id="equivalent-mutants">Equivalent Mutants</h3>
<p>Calculating the mutation score is, in practice, challenging. Why?
The mutation score increases when less mutants are alive.
This suggests that the best scenario is to have all the mutants killed by the test suite.
While this is indeed the best scenario, it is often unrealistic.
Some of the mutants are impossible to kill and will then always stay alive.</p>
<p>The mutants that cannot be killed are called equivalent mutants.
An <strong>equivalent mutant</strong> is a mutant that always behaves as the original program.
If the mutant behaves like the normal code, it will always give the same output as the original program for any given input.
Of course, this makes this mutant (which is basically the same program as the one under test) impossible to be killed by the tests.</p>
<p>Here, the equivalence is related to the definition of program equivalence.
Program equivalence roughly means that two programs are functionally equivalent when they produce the same output for every possible input.
This is also the equivalence between the normal code and an equivalent mutant.</p>
<p>Let&apos;s have a look at the following method. We left some irrelevant parts out.</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>{
  <span class="hljs-keyword">int</span> index = <span class="hljs-number">10</span>;
  <span class="hljs-keyword">while</span> (...) {
    <span class="hljs-comment">// ...</span>
    index--;
    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)
      <span class="hljs-keyword">break</span>;
  }
}
</code></pre>
<p>Our mutation testing tool generates a mutant using relational operator replacement.
The mutant is as follows:</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>{
  <span class="hljs-keyword">int</span> index = <span class="hljs-number">10</span>;
  <span class="hljs-keyword">while</span> (...) {
    <span class="hljs-comment">// ...</span>
    index--;
    <span class="hljs-keyword">if</span> (index &lt;= <span class="hljs-number">0</span>)
      <span class="hljs-keyword">break</span>;
  }
}
</code></pre>
<p>Note how the original code decremented <code>index</code>, which started at 10, and breaked from the loop when index would be equal to 0.
The mutant works exactly the same, even though the condition is technically different.
<code>index</code> is still decremented from 10 to 0.
Because <code>index</code> will never be negative, the <code>==</code> operator does the same as the <code>&lt;=</code> operator.</p>
<p>The mutant produced by the generator is an equivalent mutant in this case.</p>
<p>Because of these equivalent mutants, we need to change the mutation score formula.
We do not want to take the equivalent mutants into account, as there is nothing wrong with the tests when they do not kill these mutants.</p>
<p>The new formula becomes:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">M</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mtext>&#xA0;</mtext><mi mathvariant="normal">s</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi></mtext><mo>=</mo><mfrac><mrow><mtext><mi mathvariant="normal">k</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mtext>&#xA0;</mtext><mi mathvariant="normal">m</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">s</mi></mtext></mrow><mrow><mtext><mi mathvariant="normal">n</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">-</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mtext>&#xA0;</mtext><mi mathvariant="normal">m</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">s</mi></mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{Mutation score} = \frac{\text{killed mutants}}{\text{non-equivalent mutants}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">Mutation&#xA0;score</span></span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord text scriptstyle cramped mtight"><span class="mord mathrm mtight">non-equivalent&#xA0;mutants</span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord text scriptstyle uncramped mtight"><span class="mord mathrm mtight">killed&#xA0;mutants</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></p>
<p>For the denominator, we just count the amount of non-equivalent mutants, instead of all the mutants.
To compute this new mutation score automatically, we would need a way to automatically determine whether a mutant is an equivalent mutant.
Unfortunately, we cannot do this automatically.
<strong>Detecting equivalent mutations is an undecidable problem</strong>. We can never be sure that a mutant behaves the same as the original program for every possible input.</p>
<h2 id="application">Application</h2>
<p>Mutation testing sounds like a great way to analyse and improve our test suites.
The question is, however, if we can actually use mutation testing in practice.
For example, we can ask ourselves whether a test suite with a higher mutation score actually finds more errors.</p>
<p>A lot of research done in software engineering tries to bring some insights to this problem.
All the existing studies about mutation testing showed that mutants can indeed give a good indication for a test suite&apos;s fault detection capability, as long as the mutant operators are carefully selected and the equivalent mutants are removed.</p>
<p>More specifically, a study by Just et al. shows that mutant detection is positively correlated with real fault detection.
In other words, the more mutants a test suite detects, the more real faults the test suite can detect as well.
Even more interesting is that this correlation is independent from the coverage.
Furthermore, the correlation between mutant detection and fault detection is higher than the correlation between statement coverage and fault detection.
So, the mutation score provides a better measure for the fault detection capability than the test coverage.</p>
<h3 id="cost">Cost</h3>
<p>Of course, mutation testing is not without its costs.
We have to generate the mutants, possibly remove the equivalent mutants, and execute the tests with each mutant.
In fact, mutation testing is quite expensive, i.e., it takes a long time to perform.</p>
<p>Let&apos;s assume we want to do some mutation testing.
We have:</p>
<ul>
<li>A code base with 300 Java classes</li>
<li>10 test cases for each class</li>
<li>Each test case takes 0.2 seconds on average</li>
<li>The total test execution time is then: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mn>0</mn><mn>0</mn><mo>&#x22C5;</mo><mn>1</mn><mn>0</mn><mo>&#x22C5;</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>2</mn><mo>=</mo><mn>6</mn><mn>0</mn><mn>0</mn><mi>s</mi><mo>(</mo><mn>1</mn><mn>0</mn><mtext><mtext>&#xA0;</mtext><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mtext><mo>)</mo></mrow><annotation encoding="application/x-tex">300 \cdot 10 \cdot 0.2 = 600 s (10 \text{ min})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mbin">&#x22C5;</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mbin">&#x22C5;</span><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">2</span><span class="mrel">=</span><span class="mord mathrm">6</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord text textstyle uncramped"><span class="mord mathrm">&#xA0;min</span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>This execution time is for just the normal code.
For the mutation testing, we decide to generate on average 20 mutants per class.</p>
<p>We will have to execute the entire test suite of a class on each of the mutants.
Per class, we need <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mn>0</mn><mo>&#x22C5;</mo><mn>1</mn><mn>0</mn><mo>&#x22C5;</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>2</mn><mo>=</mo><mn>4</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">20 \cdot 10 \cdot 0.2 = 40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathrm">0</span><span class="mbin">&#x22C5;</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mbin">&#x22C5;</span><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">2</span><span class="mrel">=</span><span class="mord mathrm">4</span><span class="mord mathrm">0</span></span></span></span> seconds.
In total, the mutation testing will take <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mn>0</mn><mn>0</mn><mo>&#x22C5;</mo><mn>4</mn><mn>0</mn><mo>=</mo><mn>1</mn><mn>2</mn><mn>0</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">300 \cdot 40 = 12000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mbin">&#x22C5;</span><span class="mord mathrm">4</span><span class="mord mathrm">0</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span> seconds, or 3 hours and 20 minutes.</p>
<p>Indeed mutation testing can take a very long time.</p>
<p>Because of this cost, researchers have tried to find ways to make mutation testing faster for a long time.
Based on some observations, they came up with a couple of heuristics.</p>
<ul>
<li><p>The first observation is that a test case can never kill a mutant if it does not cover the statement that changed (also known as the <em>reachability condition</em>).
Based on this observation, we only have to run the test cases that cover the changed statement.
This reduces the amount of test cases to run and, with that, the execution time.
Furthermore, once a test case kills a mutant, we do not have to run the other test cases anymore.
This is because the test suite needs at least one test case that kills the mutant.
The exact number of test cases killing the mutant does not really matter.</p>
</li>
<li><p>A second oberservation is that mutants generated by the same operator and injected at the same location are likely to be coupled to the same type of fault.
This means that when we use a certain mutation operator (Arithmetic Operator Replacement, for example) and we replace the same statement with this mutant operator, we get two mutants that represent the same fault in the code.
It is then highly likely that if the test suite kills one of the mutants, it will also kill the others.
An heuristic that follows from this observation is to run the test suite against a subset of all the less mutants (a technique also known as <em>do fewer</em>).
Obviously, when we run the test suite against a smaller number of mutations, the overall testing will take less time.
The simplest way of selecting the subset of mutants is by means of random sampling.
As the name suggests, we just pick random mutants to consider.
This is a very simple, yet effective way to reduce the execution time.</p>
</li>
</ul>
<p>There exist other heuristics to decrease the execution time, like e-selective or cluster mutants and operators, but we will not go into detail of those heuristics.</p>
<h2 id="tools">Tools</h2>
<p>To perform mutation testing you can use one of many publicly available tools.
These tools are often made for specific programming languages.
One of the most mature mutation testing tools for Java is called <a href="http://pitest.org" target="_blank">PIT</a> or <a href="http://pitest.org" target="_blank">pitest</a>.</p>
<p>PIT can be run from the command line, but it is also integrated in most popular IDEs (like Eclipse or IntelliJ).
Project management tools like Maven or Gradle can also be configured to run PIT.</p>
<p>As PIT is a mutation testing tool, it generates the mutants and runs the test suites against these mutants.
Then it generates easy to read reports based on the results.
In these reports, you can see the line coverage and mutation score per class.
Finally, you can also see more detailed results in the source code and check which individual mutants were kept alive. Try it out!</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/BEBhTtSZAlw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>




<h2 id="exercises">Exercises</h2>
<p><strong>Exercise 1.</strong>
&quot;<em>Crimes</em> happen in a <em>city</em>. One way for us to know that the <em>police</em> is actually able to detect these <em>crimes</em>, we can <em>simulate crimes</em> and see whether the <em>police</em> is able to detect them.&quot;</p>
<p>In the analogy above, we can replace crimes by bugs, city by software, and police by test suite. What should we replace <strong>simulate crimes</strong> by?</p>
<ol>
<li>Mutation testing</li>
<li>Fuzzing testing</li>
<li>Search-based software testing</li>
<li>Combinatorial testing</li>
</ol>
<p><div class="alert alert-warning hints-alert"><div class="hints-icon"><i class="fa fa-wrench"></i></div><div class="hints-container"><p>TODO: We need to develop more exercises for this chapter</p>
</div></div></p>
<h2 id="references">References</h2>
<ul>
<li>Chapter 16 of the Software Testing and Analysis: Process, Principles, and Techniques. Mauro Pezz&#xE8;, Michal Young, 1st edition, Wiley, 2007.</li>
<li>Just, R., Jalali, D., Inozemtseva, L., Ernst, M. D., Holmes, R., &amp; Fraser, G. (2014, November). Are mutants a valid substitute for real faults in software testing?. In Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering (pp. 654-665). ACM.</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: Intelligent testing">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="fuzzing.html" class="navigation navigation-next " aria-label="Next page: Fuzzing testing">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Mutation testing","level":"5.1.1","depth":2,"next":{"title":"Fuzzing testing","level":"5.1.2","depth":2,"path":"chapters/intelligent-testing/fuzzing.md","ref":"chapters/intelligent-testing/fuzzing.md","articles":[]},"previous":{"title":"Intelligent testing","level":"5.1","depth":1,"path":"chapters/intelligent-testing/README.md","ref":"chapters/intelligent-testing/README.md","articles":[{"title":"Mutation testing","level":"5.1.1","depth":2,"path":"chapters/intelligent-testing/mutation-testing.md","ref":"chapters/intelligent-testing/mutation-testing.md","articles":[]},{"title":"Fuzzing testing","level":"5.1.2","depth":2,"path":"chapters/intelligent-testing/fuzzing.md","ref":"chapters/intelligent-testing/fuzzing.md","articles":[]},{"title":"Search-based software testing (soon)","level":"5.1.3","depth":2,"ref":"","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["hints","katex","ga"],"pluginsConfig":{"search":{},"hints":{"danger":"fa fa-exclamation-circle","info":"fa fa-info-circle","tip":"fa fa-mortar-board","working":"fa fa-wrench"},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"ga":{"configuration":"auto","token":"UA-154019382-1"},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"chapters/intelligent-testing/mutation-testing.md","mtime":"2020-03-22T11:59:34.584Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-03-22T14:45:05.136Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-ga/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

