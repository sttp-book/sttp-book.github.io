
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Test code quality and engineering Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-hints/plugin-hints.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../../assets/css/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../testing-into-context/" />
    
    
    <link rel="prev" href="tdd.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../preface/authors.html">
            
                <a href="../preface/authors.html">
            
                    
                    Authors and Acknowledgements
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../preface/use.html">
            
                <a href="../preface/use.html">
            
                    
                    Using this book
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../preface/contribute.html">
            
                <a href="../preface/contribute.html">
            
                    
                    Contribute to this book
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../preface/license.html">
            
                <a href="../preface/license.html">
            
                    
                    License
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../preface/structure.html">
            
                <a href="../preface/structure.html">
            
                    
                    Structure of the book
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../getting-started/">
            
                <a href="../getting-started/">
            
                    
                    Getting started with software testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1.1" data-path="../getting-started/why-software-testing.html">
            
                <a href="../getting-started/why-software-testing.html">
            
                    
                    Why software testing?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.2" data-path="../getting-started/testing-principles.html">
            
                <a href="../getting-started/testing-principles.html">
            
                    
                    Principles of software testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.3" data-path="../getting-started/test-automation.html">
            
                <a href="../getting-started/test-automation.html">
            
                    
                    Software testing automation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.4" data-path="../getting-started/testing-vs-writing-tests.html">
            
                <a href="../getting-started/testing-vs-writing-tests.html">
            
                    
                    Testing vs writing tests
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.5" data-path="../getting-started/developer-testing-workflow.html">
            
                <a href="../getting-started/developer-testing-workflow.html">
            
                    
                    The developer testing workflow
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../testing-techniques/">
            
                <a href="../testing-techniques/">
            
                    
                    Testing techniques
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1" data-path="../testing-techniques/specification-based-testing.html">
            
                <a href="../testing-techniques/specification-based-testing.html">
            
                    
                    Specification-based testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.2" data-path="../testing-techniques/boundary-testing.html">
            
                <a href="../testing-techniques/boundary-testing.html">
            
                    
                    Boundary testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3" data-path="../testing-techniques/structural-testing.html">
            
                <a href="../testing-techniques/structural-testing.html">
            
                    
                    Structural testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4" data-path="../testing-techniques/model-based-testing.html">
            
                <a href="../testing-techniques/model-based-testing.html">
            
                    
                    Model-based testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.5" data-path="../testing-techniques/design-by-contracts.html">
            
                <a href="../testing-techniques/design-by-contracts.html">
            
                    
                    Design-by-contracts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6" data-path="../testing-techniques/property-based-testing.html">
            
                <a href="../testing-techniques/property-based-testing.html">
            
                    
                    Property-based testing
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="./">
            
                <a href="./">
            
                    
                    Pragmatic software testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="5.1.1" data-path="testing-pyramid.html">
            
                <a href="testing-pyramid.html">
            
                    
                    The testing pyramid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.2" data-path="test-doubles.html">
            
                <a href="test-doubles.html">
            
                    
                    Test doubles
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.3" data-path="design-for-testability.html">
            
                <a href="design-for-testability.html">
            
                    
                    Design for testability
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.4" data-path="tdd.html">
            
                <a href="tdd.html">
            
                    
                    Test-driven development
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="5.1.5" data-path="test-code-quality.html">
            
                <a href="test-code-quality.html">
            
                    
                    Test code quality and engineering
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="6.1" data-path="../testing-into-context/">
            
                <a href="../testing-into-context/">
            
                    
                    Testing in the context
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="6.1.1" data-path="../testing-into-context/web-testing.html">
            
                <a href="../testing-into-context/web-testing.html">
            
                    
                    Web testing (soon)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.2" data-path="../testing-into-context/sql-testing.html">
            
                <a href="../testing-into-context/sql-testing.html">
            
                    
                    SQL testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.3" >
            
                <span>
            
                    
                    Web services testing (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.4" >
            
                <span>
            
                    
                    Mobile testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="7.1" data-path="../non-functional-testing/">
            
                <a href="../non-functional-testing/">
            
                    
                    Non-functional testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="7.1.1" data-path="../non-functional-testing/security-testing.html">
            
                <a href="../non-functional-testing/security-testing.html">
            
                    
                    Security testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="7.1.2" >
            
                <span>
            
                    
                    Performance testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="8.1" data-path="../intelligent-testing/">
            
                <a href="../intelligent-testing/">
            
                    
                    Intelligent testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="8.1.1" data-path="../intelligent-testing/static-testing.html">
            
                <a href="../intelligent-testing/static-testing.html">
            
                    
                    Static testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.1.2" data-path="../intelligent-testing/mutation-testing.html">
            
                <a href="../intelligent-testing/mutation-testing.html">
            
                    
                    Mutation testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.1.3" data-path="../intelligent-testing/fuzzing.html">
            
                <a href="../intelligent-testing/fuzzing.html">
            
                    
                    Fuzz testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.1.4" data-path="../intelligent-testing/sbst.html">
            
                <a href="../intelligent-testing/sbst.html">
            
                    
                    Search-based testing
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="9.1" >
            
                <span>
            
                    
                    Appendix
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="9.1.1" data-path="../appendix/answers.html">
            
                <a href="../appendix/answers.html">
            
                    
                    Answers to the exercises
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="9.1.2" data-path="../testing-techniques/domain-testing.html">
            
                <a href="../testing-techniques/domain-testing.html">
            
                    
                    Domain testing examples
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="9.1.3" data-path="../appendix/2020-midterm-preparation.html">
            
                <a href="../appendix/2020-midterm-preparation.html">
            
                    
                    2020 midterm mock exam
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="9.1.4" data-path="../appendix/2020-midterm-preparation-answers.html">
            
                <a href="../appendix/2020-midterm-preparation-answers.html">
            
                    
                    2020 midterm mock exam (answers)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="9.1.5" data-path="../appendix/changelog.html">
            
                <a href="../appendix/changelog.html">
            
                    
                    Change log
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Test code quality and engineering</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="test-code-quality-and-engineering">Test code quality and engineering</h1>
<p>You probably noticed that, once <em>test infected</em>, 
the amount of JUnit code that a software development team writes and maintain
is quite significant. In practice,
test code bases tend to grow very fast. Empirically, we have been observing
that Lehman&apos;s laws of evolution also apply to test code: code tends to rot, unless
one actively works against it. Thus,
as with production code, <strong>developers have to put extra effort 
in making high-quality test code bases, so that it can be maintained and evolved in a
sustainable way</strong>.</p>
<p>In this chapter, we go over some best practices 
in test code engineering. More specifically:</p>
<ul>
<li>A set of principles that should guide developers when writing test code.
For those, we discuss both the FIRST principles (from the Pragmatic Unit Testing book),
as well as the recent Test Desiderata (proposed by Kent Beck)</li>
<li>A set of well-known test smells that might emerge in test code.</li>
<li>Some tips on how to make tests more readable.</li>
<li>What flaky tests are and their possible causes.</li>
</ul>
<h2 id="the-first-principles">The FIRST principles</h2>
<p>In the Pragmatic Unit Testing book, the authors discuss the &quot;FIRST Properties of Good Tests&quot;.
FIRST is an acronym for fast, isolated, repeatable, self-validating, and timely:</p>
<ul>
<li><strong>Fast</strong>: 
Tests are the safety net of a developer. Whenever developers perform any maintenance
or evolution in the source code, they use the feedback of the test suite to understand
whether the system is still working as expected. 
The faster the feedback a developer gets from their test code, the better.
On the other hand, slower test suites force developers to simply run the tests less often,
making them less effective. Therefore, good tests are fast.
There is no hard line that separates slow from fast tests. Good sense is fundamental.
Once you are facing a slow test, you might consider:<ul>
<li>Making use of mocks/stubs to replace slower components that are part of the test</li>
<li>Re-designing the production code so that slower pieces of code can be tested separately from fast pieces of code</li>
<li>Moving slower tests to a different test suite, one that developers might run less often. 
It is not uncommon to see developers having sets of unit tests that run fast, and these they run all day long, and sets of slower integration and system tests that run once or twice a day in the Continuous Integration server. </li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Isolated</strong>: Tests should be as cohesive, as independent, and as isolated as possible. 
Ideally, a single test method should test just a single functionality or behaviour of the system.
Having fat tests (or, as the test smells community calls it, eager tests) that test
multiple functionalities are often complex in terms of implementation. Complex test code reduces
the ability of developers to understand what it tests in a glance, and makes future maintenance
harder. If you are facing such a test, break it into multiple smaller tests. Simpler and shorter
code is always better.</p>
<p>  Moreover, tests should not depend on other tests to run. The result of a test should be the
  same, whether the test is executed in isolation or together with the rest of the test suite.
  It is not uncommon to see cases where some test B only works if test A is executed before it.
  This is often the case when test B relies on the work of test A to set up the environment
  for it. Such tests become highly unreliable, as they might fail just because the
  developer forgot about such a detail. In such cases, refactor the test code so that the tests
  are responsible for setting up all the environment they need. If tests A and B depend on
  similar resources, make sure they can share the same code, so that you avoid duplicating
  code. JUnit&apos;s <code>@BeforeEach</code> or <code>@BeforeAll</code> methods can become handy. Moreover, make sure
  that your tests &quot;clean up their messes&quot;, e.g., by deleting any possible files it created
  on the disk, or cleaning up values it inserted in a database.</p>
</li>
</ul>
<ul>
<li><strong>Repeatable</strong>: A repeatable test is a test that gives the same result, no matter how many times it is executed.
Developers tend to lose their trust in tests that present a flaky behaviour (i.e., it sometimes passes, and sometimes fails without any changes in the system and/or in the test code).
Flaky tests might happen for different reasons, and some of the causes can be tricky
to identify (companies have reported extreme examples where a test presented a flaky behaviour
only once in a month). Common causes are dependencies on external resources, not waiting long
enough for an external resource to finish its task, and concurrency.</li>
</ul>
<ul>
<li><strong>Self-validating</strong>: 
The tests should validate/assert the result themselves. This might seem an unnecessary
principle to mention. However, it is not uncommon for developers to make mistakes and to not write
assertions in the test, causing the test to always pass. In other more complex cases,
writing the assertions or, in other words, verifying the expected behaviour, might not be possible.
In cases where observing the outcome of a behaviour is not easily achievable, we suggest
the developer to refactor the class or method under test to increase its observability (revisit
our chapter on design for testability).</li>
</ul>
<ul>
<li><p><strong>Timely</strong>: 
Developers should be <em>test infected</em>. They should write and run tests as often
as possible. While less technical than the other principles in this list, changing
the behaviour of development teams towards writing automated test code can still be challenging.</p>
<p>  Leaving the test phase to the very end of the development process, as commonly done
  in the past, might incur in
  unnecessary costs. After all, at that point, the system might be simply hard to test.
  Moreover, as we have seen, tests serve as a safety net to developers. Developing large
  complex systems without such a net is highly unproductive and prone to fail.</p>
</li>
</ul>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/5wLrj-cr9Cs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>



<h2 id="test-desiderata">Test Desiderata</h2>
<p>Kent Beck, the &quot;creator&quot; of Test-Driven Development (and author of the 
<a href="https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530" target="_blank">&quot;Test-Driven Development: By Example&quot;</a> book), recently wrote a list of eleven
properties that good tests have (the <a href="https://medium.com/@kentbeck_7670/test-desiderata-94150638a4b3" target="_blank">test desiderata</a>). </p>
<p>The following list comes directly from his blog post. Note how some of these principles
are also part of the FIRST principles.</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=HApI2cspQus" target="_blank">Isolated</a>: tests should return the same results regardless of the order in which they are run.</li>
<li><a href="https://www.youtube.com/watch?v=Wf3WXYaMt8E" target="_blank">Composable</a>: if tests are isolated, then I can run 1 or 10 or 100 or 1,000,000 and get the same results.</li>
<li><a href="https://www.youtube.com/watch?v=L0dZ7MmW6xc" target="_blank">Fast</a>: tests should run quickly.</li>
<li><a href="https://www.youtube.com/watch?v=2Q1O8XBVbZQ" target="_blank">Inspiring</a>: passing the tests should inspire confidence</li>
<li><a href="https://www.youtube.com/watch?v=CAttTEUE9HM" target="_blank">Writable</a>: tests should be cheap to write relative to the cost of the code being tested.</li>
<li><a href="https://www.youtube.com/watch?v=bDaFPACTjj8" target="_blank">Readable</a>: tests should be comprehensible for their readers, invoking the motivation for writing this particular test.</li>
<li><a href="https://www.youtube.com/watch?v=5LOdKDqdWYU" target="_blank">Behavioural</a>: tests should be sensitive to changes in the behaviour of the code under test. If the behaviour changes, the test result should change.</li>
<li><a href="https://www.youtube.com/watch?v=bvRRbWbQwDU" target="_blank">Structure-insensitive</a>: tests should not change their result if the structure of the code changes.</li>
<li><a href="https://www.youtube.com/watch?v=YQlmP08dj6g" target="_blank">Automated</a>: tests should run without human intervention.</li>
<li><a href="https://www.youtube.com/watch?v=8lTfrCtPPNE" target="_blank">Specific</a>: if a test fails, the cause of the failure should be obvious.</li>
<li><a href="https://www.youtube.com/watch?v=PwWyp-wpFiw" target="_blank">Deterministic</a>: if nothing changes, the test result should not change.</li>
<li><a href="https://www.youtube.com/watch?v=7o5qxxx7SmI" target="_blank">Predictive</a>: if the tests all pass, then the code under test should be suitable for production.</li>
</ul>
<p>For more interested readers, watch <a href="https://www.youtube.com/watch?v=lXTwxMxNx-Y" target="_blank">Kent Beck talking about it in an open talk</a>.</p>
<h2 id="test-code-smells">Test code smells</h2>
<p>Now that we covered some best practices, let us look at the other
side of the coin: <strong>test code smells</strong>.</p>
<p>The term <em>code smell</em> is a well-known term that indicates possible symptoms that might
indicate deeper problems in the source code of the system. 
Some very well-known examples are <em>Long Method</em>, <em>Long Class</em>, or <em>God Class</em>.
A good number of research papers show us that code smells hinder the comprehensibility and the maintainability of software systems.</p>
<p>While the term has been long applied to production code, given
the rise of test code, our community has been developing catalogues of smells that
are now specific to test code.
Research has also shown that test smells are prevalent in real life and, unsurprisingly, often negatively impact the maintenance and comprehensibility of the test suite.</p>
<p>In the following, we will discuss several of the well-known test smells. A more comprehensive
list can be found in the xUnit Test Patterns book, by Meszaros.</p>
<p><strong>Code Duplication</strong>: 
It is not surprising that code duplication might also happen in test code, 
as it is very common in production code.
Tests are often similar in structure. You might have noticed it in several of the code
examples throughout this book. We even made use of JUnit&apos;s Parameterized Tests feature
to reduce some of the duplication.
A less attentive developer might end up writing duplicated code 
(copying and pasting often happens in real life) instead of putting
some effort in implementing a better solution. </p>
<p>Duplicated code might reduce the productivity of software testers.
After all, if there is a need for a change in a duplicated piece of code, a developer
will have to apply the same change over and over again, at all places where the code was duplicated. 
In practice, it is easy to skip one of these places, ending up with 
problematic test code.
Note that the effects are similar to the effects of code duplication in production code.</p>
<p>We suggest developers to ruthlessly refactor their test code. The extraction of a duplicated piece of
code to private methods or external classes is often a good solution for the problem.</p>
<p><strong>Assertion Roulette</strong>:
Assertions are the first thing a developer looks at when a test is failing.
Assertions, thus, have to clearly communicate what is going wrong with the component
under test. 
The test smell emerges when it is hard to understand the 
assertions themselves, or why they are failing.</p>
<p>There are several reasons for this smell to happen. Some features or business rules
are simply too complex and require a complex set of assertions to ensure their behaviour.
Suddenly, developers end up writing complex assert instructions that are not easy to
understand. In such cases, we recommend developers to 1) write their own customised
assert instructions that abstract away part of the complexity of the assertion code itself,
2) when expressing it in code is not enough, write code comments that quickly explain, in natural language, what those assertions are about.</p>
<p>Interestingly, a common best practice that is often found in the test best practice literature is the &quot;one assertion per method&quot; strategy. While forcing developers to have just a single assertion per test method is too extremist, the idea of minimising the number of assertions in a test method is valid.</p>
<p>Note that a high number of simple assertions in a single test might be as harmful as a complex
set of assertions. In such cases, we provide a similar recommendation: write a customised
assertion instruction to abstract away the need for long sequences of assertions.</p>
<p>Empirically, we also observe that the number of assertions in a test is often large, because
developers tend to write more than one test case in a single test method. We also have done
that in this book (see the boundary testing chapter, where we test both sides of the boundary
in a single test method). However, parsimony is fundamental. Splitting up a large test method
that contains multiple test cases might reduce the cognitive load required by the developer
to understand it.</p>
<p><strong>Resource Optimism</strong>:
Resource optimism happens when a test assumes that a necessary resource (e.g., a database) is readily available at the start of its execution. This is related to the <em>isolated</em> principle
of the FIRST principles and of Beck&apos;s test desiderata.</p>
<p>To avoid resource optimism, a test should not assume that the resource is already in the correct state. The test should be the one responsible for setting up the state itself. This might mean that
the test is the one responsible for populating a database, for writing the required files in the disk, or for starting up a Tomcat server. (This set up might require complex code, and developers
should also do their best effort in abstracting way such complexity by, e.g., moving such 
code to other classes, e.g., <code>DatabaseInitialization</code> or <code>TomcatLoader</code>, allowing the
test code to focus on the test cases themselves).</p>
<p>Similarly, another incarnation of the resource optimism smell happens
when the test assumes that the resource is available all the time.
Suppose a test method that interacts with a webservice.
The webservice might be down for reasons we do not control.</p>
<p>To avoid this test smell, developers have two options:
First, to avoid using external resources, by using stubs and mocks.
However, if the test cannot avoid using the external dependency, make it robust enough.
In that case, make your test suite skip that test when the resource is unavailable, and provide a message explaining why that was the case. This seems counterintuitive, but again, remember
that developers trust their test suites. Having a single test failing for the wrong reasons
makes developers lose their confidence in the entire test suite.</p>
<p>In addition to changing your tests, developers must make sure 
that the environments, where the tests are executed, have the required resources available.
Continuous integration tools like Jenkins, CircleCI, and Travis can help developers in 
making sure that tests are being run in the correct environment.</p>
<p><strong>Test Run War</strong>:
The war is an analogy for when two tests are &quot;fighting&quot; for the same resources.
One can observe a test run war when tests start to fail as soon as more than one developer
run their test suites.
Imagine a test suite that uses a centralised database. When developer A runs the test, the test changes the state of the database. At the same time, 
developer B runs the same test, which also goes to the same database. 
Thus, both tests are touching the same database at the same time. 
This unexpected situation might cause the test to fail.</p>
<p><em>Isolation</em> is key to avoid this test smell. In the example of a centralised database,
one solution would be to make sure each developer has its own instance of a database. That would
avoid the fight for the same resource. (Related to this example, we discuss more about 
database testing in a specific chapter).</p>
<p><strong>General Fixture</strong>:
A fixture is the set of input values that will be used to exercise the component under test.
We have called <em>fixture</em> the <em>arrange</em> part of the test before.
As you might have noticed, fixtures are the &quot;stars&quot; of the test method, as they derive
naturally from the test cases we devised using any of the techniques we have discussed. </p>
<p>When testing more complex components, developers might need to make use of several
different fixtures; one for each partition they want to exercise. These fixtures might
then become complex. And worst: while tests are different from each other, their fixtures
might have some intersection. </p>
<p>Given this possible intersection among the different fixtures, as well as the difficulty
that it is to keep building these complex entities and fixtures, a less attentive developer
might decide to declare a &quot;large&quot; fixture that works for many different tests. Each test
would then use a small part of this large fixture. </p>
<p>While this approach might work and tests might correctly implement the test cases,
they will be hard to maintain. Once a test fails, developers with the mission
of understanding the cause of the failure, will face a large fixture that is not totally
relevant for/of interest to them. In practice, the developer would have to manually
&quot;filter out&quot; part of the fixture that are not really exercised by the failing test.
That is an unnecessary cost.
Making sure that the fixture of a test is as specific and cohesive as possible helps
developers in comprehending the essence of a test (which is often highly relevant when
the test starts fail).</p>
<p>Build patterns, with the focus of building test data, 
might help developers in avoiding such a smell. More specifically, 
the <strong><a href="http://www.natpryce.com/articles/000714.html" target="_blank">Test Data Builder</a></strong> is
an often used design pattern in test code of enterprise applications (we give an example
of a Test Data Builder later in this chapter). Such applications
often have to deal with the creation of complex sets of interrelated 
business entities, which can easily
lead developers to write general fixtures.</p>
<p><strong>Indirect tests</strong> and <strong>eager tests</strong>:
Tests should be as cohesive and as focused as possible. A testing class <code>ATest</code> that aims at testing
some class <code>A</code> should solely focus on testing this class <code>A</code>. Even if it depends on a class
<code>B</code>, requiring <code>ATest</code> to instantiate <code>B</code>, <code>ATest</code> should focus on exercising <code>A</code> and <code>A</code> only.
The smell, however, emerges when a test class focuses its efforts on testing many classes
at once. </p>
<p>Less cohesive tests harm productivity. How do developers know where tests for a given <code>B</code> class
are? If test classes focus on more than a single class, tests for <code>B</code> might be anywhere.
Developers would have to look for them. 
It is also expected that, without proper care, tests for a single class would live in
many other test classes, e.g., tests for <code>B</code> might exist in <code>ATest</code>, <code>BTest</code>, <code>CTest</code>, etc.</p>
<p>Tests, and more specifically, unit test classes and methods, should have a clear focus.
They should test a single unit. If they have to depend on other classes, the use of
mocks and stubs might help the developer in isolating that test and avoid <em>indirect
testing</em>. If the use of mocks and stubs is not possible, make sure that assertions
focus on the real class under test, and that failures caused by dependencies (and not 
by the class under test) are clearly indicated in the outcome of the test method.</p>
<p>Similar to what we have discussed when talking about the excessive number of assertions
in a single test, avoiding <em>eager tests</em>, or tests that exercise more than a unique
behaviour of the component is also a best practice. Test methods that exercise multiple
behaviours at once tend to be overly long and complex, making it harder for developers
to comprehend them in a quick glance.</p>
<p><strong>Sensitive Equality</strong>:
Good assertions are fundamental in test cases. A bad assertion might lead a test
to not fail when it should. However, a bad assertion might also lead a test <em>to fail
when it should not</em>.
Engineering a good assertion statement is challenging. Even more so when components
produce fragile outputs, i.e., outputs that tend to change often. 
Test code should be as resilient as possible to the implementation details
of the component under test. Assertions should also be not too sensitive to internal
changes. </p>
<p>Imagine a class <code>Item</code> that represents an item of a cart shop. 
An item is composed of a name, a quantity, and an individual price. The final price
of the item is the multiplication of its quantity per its individual price.
The class has the following implementation:</p>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.math.BigDecimal;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> qty;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigDecimal individualPrice;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Item</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> qty, BigDecimal individualPrice)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.qty = qty;
        <span class="hljs-keyword">this</span>.individualPrice = individualPrice;
    }

    <span class="hljs-comment">// getters ...</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">finalAmount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> individualPrice.multiply(<span class="hljs-keyword">new</span> BigDecimal(qty));
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product &quot;</span> + name + <span class="hljs-string">&quot; times&quot;</span> + qty + <span class="hljs-string">&quot; = &quot;</span> + finalAmount();
    }
}
</code></pre>
<p>Suppose now that a less attentive developer writes the following test as to exercise
the <code>finalAmount</code> behaviour:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemTest</span> </span>{

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qtyTimesIndividualPrice</span><span class="hljs-params">()</span> </span>{
        var item = <span class="hljs-keyword">new</span> Item(<span class="hljs-string">&quot;Playstation IV with 64 GB and super wi-fi&quot;</span>,
                <span class="hljs-number">3</span>,
                <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;599.99&quot;</span>));

        <span class="hljs-comment">// this is too sensitive!</span>
        Assertions.assertEquals(<span class="hljs-string">&quot;Product Playstation IV with 64 GB &quot;</span> +
                <span class="hljs-string">&quot;and super wi-fi times &quot;</span> + <span class="hljs-number">3</span> + <span class="hljs-string">&quot; = 1799.97&quot;</span>, item.toString());
    }
}
</code></pre>
<p>The test above indeed exercises the calculation of the final amount. However,
one can see that the developer took a shortcut. (S)he decided to assert the overall
behaviour by making use of the <code>toString</code> method of the class. Maybe because
the developer felt that this assertion was more strict, as it asserts not only
the final price, but also the name of the product and its quantity. </p>
<p>While this seems to work at first,
this assertion is sensitive to changes in the implementation of the <code>toString</code>. </p>
<p>Clearly,
the tester does not want its test to break if the <code>toString</code> changes, but only if the
<code>finalAmount</code> method changes. That is not what happens. Suppose that another developer
decided to shorten the length of the outcome of the <code>toString</code>:</p>
<pre><code class="lang-java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product &quot;</span> + name.substring(<span class="hljs-number">0</span>, Math.min(<span class="hljs-number">11</span>, name.length())) + 
      <span class="hljs-string">&quot; times &quot;</span> + qty + <span class="hljs-string">&quot; = &quot;</span> + finalAmount();
}
</code></pre>
<p>Suddenly, our <code>qtyTimesIndividualPrice</code> test fails:</p>
<pre><code>org.opentest4j.AssertionFailedError: 
Expected :Product Playstation IV with 64 GB and super wi-fi times 3 = 1799.97
Actual   :Product Playstatio times 3 = 1799.97
</code></pre><p>A better assertion for this would be to assert precisely what is wanted from that behaviour.
In this case, assert that the final amount of the item is correctly calculated. A better
implementation for the test would be:</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qtyTimesIndividualPrice_lessSensitiveAssertion</span><span class="hljs-params">()</span> </span>{
    var item = <span class="hljs-keyword">new</span> Item(<span class="hljs-string">&quot;Playstation IV with 64 GB and super wi-fi&quot;</span>,
            <span class="hljs-number">3</span>,
            <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;599.99&quot;</span>));

    Assertions.assertEquals(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;1799.97&quot;</span>), item.finalAmount());
}
</code></pre>
<p>Remember our discussion regarding design for testability. It might be better to 
create a method with a sole purpose of facilitating the test (or, in this case, the assertion)
rather than having to rely on sensitive assertions that will possibly break the test
for the wrong reason in the future.</p>
<p><strong>Inappropriate assertions</strong>: Somewhat related to the
previous smell, having the proper assertions makes a huge
difference between a good and a bad test case. While we have discussed how to derive
good test cases (and thus, good assertions), choosing the right implementation strategy
for writing the assertion can impact the maintenance of the test in the long run.
The wrong choice of an assertion instruction might give developers less information
about the failure, making the debugging process more difficult.</p>
<p>Imagine a very simplistic implementation of a <code>Cart</code> that receives products
to be inserted into it. Products can not be repeated. A simple implementation might be:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cart</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; items = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String product)</span> </span>{
        items.add(product);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberOfItems</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> items.size();
    }
}
</code></pre>
<p>Now, a developer decided to test the <code>numberOfItems</code> behaviour. (S)he then wrote the following
test cases:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartTest</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Cart cart = <span class="hljs-keyword">new</span> Cart();

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">numberOfItems</span><span class="hljs-params">()</span> </span>{
        cart.add(<span class="hljs-string">&quot;Playstation&quot;</span>);
        cart.add(<span class="hljs-string">&quot;Big TV&quot;</span>);

        assertTrue(cart.numberOfItems() == <span class="hljs-number">2</span>);
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ignoreDuplicatedEntries</span><span class="hljs-params">()</span> </span>{
        cart.add(<span class="hljs-string">&quot;Playstation&quot;</span>);
        cart.add(<span class="hljs-string">&quot;Big TV&quot;</span>);
        cart.add(<span class="hljs-string">&quot;Playstation&quot;</span>);

        assertTrue(cart.numberOfItems() == <span class="hljs-number">2</span>);
    }
}
</code></pre>
<p>Note that the less attentive developer opted for an <code>assertTrue</code>. While the test
works as expected, if it ever fails (which we can easily force by replacing the Set for a List
in the <code>Cart</code> implementation), the assertion error message will be like
as follows:</p>
<pre><code>org.opentest4j.AssertionFailedError: 
Expected :&lt;true&gt; 
Actual   :&lt;false&gt;
</code></pre><p>The error message does not explicitly show the difference in the values. In this
simple example, it might seem that it is not too important, but take this to more 
complicated test cases. In the real world, a developer would have to add some debugging
code (<code>System.out.println</code>s) to print the actual value that was produced by the method.</p>
<p>The test could help the developer by giving as much information as possible. To that aim,
choosing the right assertions is important, as they tend to give more information. 
In this case, the use of an <code>assertEquals</code> is a better fit:</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">numberOfItems</span><span class="hljs-params">()</span> </span>{
    cart.add(<span class="hljs-string">&quot;Playstation&quot;</span>);
    cart.add(<span class="hljs-string">&quot;Big TV&quot;</span>);

    <span class="hljs-comment">// assertTrue(cart.numberOfItems() == 2);</span>
    assertEquals(<span class="hljs-number">2</span>, cart.numberOfItems());
}
</code></pre>
<p>Libraries such as AssertJ, besides making the assertions more legible, also
help us in providing better error messages. Suppose our <code>Cart</code> class now has a 
<code>allItems()</code> method that returns all items that were previously stored in this cart:</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">allItems</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> Collections.unmodifiableSet(items);
}
</code></pre>
<p>Asserting the outcome of this method using plain old JUnit assertions would look
like the following:</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">allItems</span><span class="hljs-params">()</span> </span>{
    cart.add(<span class="hljs-string">&quot;Playstation&quot;</span>);
    cart.add(<span class="hljs-string">&quot;Big TV&quot;</span>);

    var items = cart.allItems();

    assertTrue(items.contains(<span class="hljs-string">&quot;Playstation&quot;</span>));
    assertTrue(items.contains(<span class="hljs-string">&quot;Big TV&quot;</span>));
}
</code></pre>
<p>AssertJ enables us to assert not only the items, but also the structure of the set itself.
For example, by making sure it <em>only</em> contains these two items, in a single assertion (note
the <code>containsExactlyInAnyOrder()</code> that does exactly what its name says):</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">allItems</span><span class="hljs-params">()</span> </span>{
    cart.add(<span class="hljs-string">&quot;Playstation&quot;</span>);
    cart.add(<span class="hljs-string">&quot;Big TV&quot;</span>);

    var items = cart.allItems();

    assertThat(items).containsExactlyInAnyOrder(<span class="hljs-string">&quot;Playstation&quot;</span>, <span class="hljs-string">&quot;Big TV&quot;</span>);
}
</code></pre>
<p>Thus, we recommend developers to choose wisely how to write the assertion statements.
A good assertion clearly reveals its reason for failing, is legible, and is as specific
and less sensitive as possible.</p>
<p><strong>Mystery Guest</strong>: (Integration) tests often rely on external 
dependencies. They might be databases, files in the disk, or webservices (the &quot;guest&quot;). 
While such dependencies are unavoidable in these types of tests, making them clearly explicit
in the test code might help developers in cases where these tests suddenly start to fail.
A test that makes use of a guest, but hides it from the developer (making it 
a &quot;mystery guest&quot;) is simply harder to comprehend.</p>
<p>Make sure your test gives proper error messages, differentiating between a fail in the
expected behaviour, or a fail due to a problem in the guest. Having assertions dedicated
to ensure that the guest is in the right state before running the tests is often
the remedy that is applied to this smell.</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/QE-L818PDjA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>




<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/DLfeGM84bzg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>



<h2 id="test-code-readability">Test code readability</h2>
<p>We have discussed several test code best practices and smells. In many situations,
we have argued for the need of comprehensible, i.e., easy to read, test code.</p>
<p>We reinforce the fact that it 
is crucial that the developers can understand the test code easily.
<strong>We need readable and understandable test code.</strong> 
Note that &quot;readability&quot; is one of the test desiderata we mentioned above.</p>
<p>In the following, we present some of our personal tips on how to write readable test code.</p>
<p>The first tip concerns the <strong>structure of your tests</strong>.
As you have seen earlier, tests all follow the same structure: the Arrange, Act and Assert
structure.
When <strong>these three parts are clearly separated, it is easier for a developer to see what is happening in the test</strong>.
Your tests should make sure that a developer can quickly glance and identify these 
three different parts. Where is the fixture? Where is the behaviour/method under test? 
Where are the assertions?</p>
<p>A second tip concerns the <strong>comprehensibility of the information</strong> in a test code.
Test code is full of information, i.e., the input values that will be provided
to the class under test, how the information flows up to the method under test, 
how the output comes back from the exercise behaviour, and what the expected outcomes are.</p>
<p>However, we often have to deal with complex data structures and information, making 
the test code naturally complex.
To that aim, <strong>we should make sure that the (meaning of the) 
important information present in a test is easy to understand.</strong></p>
<p>Giving descriptive names to the information in the test code is a good remedy.
Let us illustrate it in the example below.
Suppose we have written a test for an <code>Invoice</code> class, that calculates the tax relative
to that invoice.</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoice</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigDecimal value;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String country;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CustomerType customerType;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Invoice</span><span class="hljs-params">(BigDecimal value, String country, CustomerType customerType)</span> </span>{
        <span class="hljs-keyword">this</span>.value = value;
        <span class="hljs-keyword">this</span>.country = country;
        <span class="hljs-keyword">this</span>.customerType = customerType;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">double</span> ratio = <span class="hljs-number">0.1</span>;

        <span class="hljs-comment">// some business rule here to calculate the ratio</span>
        <span class="hljs-comment">// depending on the value, company/person, country ...</span>

        <span class="hljs-keyword">return</span> value.multiply(<span class="hljs-keyword">new</span> BigDecimal(ratio));
    }
}
</code></pre>
<p>A not-so-clear test code for the <code>calculate()</code> method could be:</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
    var invoice = <span class="hljs-keyword">new</span> Invoice(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;2500&quot;</span>), <span class="hljs-string">&quot;NL&quot;</span>, CustomerType.COMPANY);
    var v = invoice.calculate();
    assertEquals(<span class="hljs-number">250</span>, v.doubleValue(), <span class="hljs-number">0.0001</span>);
}
</code></pre>
<p>Note how, at first glance, it might hard to understand what all the information that is
present in the code means. It might be require some extra effort to understand what
this invoice looks like. Imagine now a real entity from a real enterprise system: an <code>Invoice</code>
class might have dozens of attributes. The name of the test as well as the name of
the cryptic variable <code>v</code> do not clearly explain what they mean. For developers less fluent
in JUnit, it might also be hard to understand what the 0.0001 means (it represents a delta;
double numbers in Java might have problems with rounding, so the assertion makes sure that both numbers are equal, within a plus or minus delta value).</p>
<p>A better version for this test method could be:</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">taxesForCompanies</span><span class="hljs-params">()</span> </span>{
    var invoice = <span class="hljs-keyword">new</span> InvoiceBuilder()
            .asCompany()
            .withCountry(<span class="hljs-string">&quot;NL&quot;</span>)
            .withAValueOf(<span class="hljs-string">&quot;2500&quot;</span>)
            .build();

    var calculatedValue = invoice.calculate();

    assertThat(calculatedValue).isCloseTo(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;250&quot;</span>), within(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.001&quot;</span>)));
}
</code></pre>
<p>Note how our <code>InvoiceBuilder</code> (which we show the implementation soon) clearly expresses what
this invoice is about: it is an invoice for a company (as clearly stated by the <code>asCompany()</code> 
method), &quot;NL&quot; is the country of that invoice, and the invoice has a value of 2500. The
result of the behaviour now goes to a variable whose name says it all (<code>calculatedValue</code>). 
The assertion then explicitly mentions that, given this is a float number, the best we can do
is to compare whether they are close enough.</p>
<p>The <code>InvoiceBuilder</code> is an example of an implementation of a <strong>Test Data Builder</strong>, the design
pattern we mentioned before. The builder helps developers in creating fixtures, by providing
them with a clear and expressive API. The use of fluent interface (e.g., <code>asCompany().withAValueOf()...</code>) is also a common implementation choice, as it enables
developers to simply type less. In terms of coding, the <code>InvoiceBuilder</code> is simply
a Java class. The trick that allows methods to be chained is to return the class itself
in the methods (note that methods return <code>this</code>).</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InvoiceBuilder</span> </span>{

    <span class="hljs-keyword">private</span> String country = <span class="hljs-string">&quot;NL&quot;</span>;
    <span class="hljs-keyword">private</span> CustomerType customerType = CustomerType.PERSON;
    <span class="hljs-keyword">private</span> BigDecimal value = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;500.0&quot;</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> InvoiceBuilder <span class="hljs-title">withCountry</span><span class="hljs-params">(String country)</span> </span>{
        <span class="hljs-keyword">this</span>.country = country;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> InvoiceBuilder <span class="hljs-title">asCompany</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.customerType = CustomerType.COMPANY;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> InvoiceBuilder <span class="hljs-title">withAValueOf</span><span class="hljs-params">(String value)</span> </span>{
        <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">new</span> BigDecimal(value);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Invoice <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Invoice(value, country, customerType);
    }
}
</code></pre>
<p>Developers should feel free to customise their builders as much as they want. A common
trick is to make the builder to build a &quot;common&quot; version of the class, without requiring
the call of all the setup methods. This way, a developer can do:</p>
<pre><code class="lang-java">var invoice = <span class="hljs-keyword">new</span> InvoiceBuilder().build();
</code></pre>
<p>In such case, the <code>build</code> method, without any setup, will always build an invoice
for a person, with a value of 500.0, and having NL as country (see the initialised
values in the <code>InvoiceBuilder</code>). </p>
<p>Other developers might even give the build several shortcut methods that build other
&quot;common&quot; fixtures for the class. For example, the following methods could very much 
exist in the Builder.
The <code>anyCompany()</code> method simply returns an Invoice that belongs to a company (and the
default value for the other fields). The <code>anyUS</code> builds an Invoice for someone in the US:</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> Invoice <span class="hljs-title">anyCompany</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Invoice(value, country, CustomerType.COMPANY);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> Invoice <span class="hljs-title">anyUS</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Invoice(value, <span class="hljs-string">&quot;US&quot;</span>, customerType);
}
</code></pre>
<p>Note how test data builders might help developers in avoiding general fixtures.
Given that the builder makes it easier to build complex objects, developers might not
feel the need to rely so much on a general fixture.</p>
<p>Introducing test data builders, making good use of variable names to explain the meaning
of the information, having clear assertions, and (although not exemplified here) having
comments in cases where code is not expressive enough will help developers in better
comprehending test code.</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/RlqLCUl2b0g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>


<h2 id="flaky-tests">Flaky tests</h2>
<p>Flaky tests (or <em>erratic tests</em>, as Mezsaros calls them in his book)
are tests that present a &quot;flaky&quot; behaviour: 
they sometimes pass and sometimes fail, even though
developers have not performed any changes in their software systems.</p>
<p>Such tests negatively impact the productivity of software development teams.
First, it is hard to know whether a flaky test is failing because the behaviour
is buggy, or because it is simply flaky. From the social side, the excessive
presence of flaky tests make developers lose their confidence in their test
suites, little by little. The lack of confidence might lead them to deploy their
systems even though the tests are red (after all, they might be broken just because
of flakiness, and not because the system is misbehaving).</p>
<p>The prevalence, and thus, the impact of flaky tests in the software development
world has been increasing over time. Companies like Google and Facebook as well
as software engineering researchers have been
extensively working towards automated ways of detecting and fixing flaky tests.</p>
<p>Flaky tests can have a lot of causes.
We will name a few reasons:</p>
<ul>
<li><p>A test can be flaky because it <strong>depends on external and/or shared resources</strong>.
Let us say we need a database to run our tests.
Sometimes the test passes, because the database is available; sometimes it fails, because the database is not available. Sometimes the test passes because the database is clean and
ready for that test; sometimes the test fails because the same test was being run by
the next developer and the database was not in a clean state.</p>
</li>
<li><p>The tests can be flaky due to improper time-outs.
This is a common cause in web testing.
Suppose a test has to wait for something to happen in the system, e.g., a request
coming back from a webservice, which is then displayed in some HTML element.
If the web application is a bit slower than normal, the test might suddenly fail, just
because &quot;it did not wait enough&quot;.</p>
</li>
<li><p>Tests can be flaky due to a possible hidden interaction between different
test methods.
Suppose that test A somehow influences the result of test B, 
possibly causing it to fail.</p>
</li>
</ul>
<p>As you might have noticed, some of these causes 
correspond to scenarios we described when discussing the test smells.
The quality of our test code is thus very important.</p>
<p><div class="alert alert-success hints-alert"><div class="hints-icon"><i class="fa fa-mortar-board"></i></div><div class="hints-container"><p>If you want to find the exact cause of a flaky test, 
the author of the XUnit Test Patterns book has made a whole decision table.
You can find it in the book or on Gerard Meszaros&apos; website <a href="http://xunitpatterns.com/Erratic%20Test.html" target="_blank">here</a>.
With the decision table you can find a probable cause for the flakiness of your test.</p>
<p>We list several interesting research papers on flaky tests, their impact on software testing, and current state-of-the-art detection tools in our references section.</p>
</div></div></p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/-OQgBMSBL5c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>







<h2 id="exercises">Exercises</h2>
<p><strong>Exercise 1.</strong>
Jeanette just heard that two tests are behaving strangely: when executed in isolation, both of them pass. However, when executed together, they fail. Which one of the following <strong>is not</strong> cause for this?</p>
<ol>
<li>Both tests are very slow.</li>
<li>They depend upon the same external resources.</li>
<li>The execution order of the tests matter.</li>
<li>They do not perform a clean-up operation after execution.</li>
</ol>
<p><strong>Exercise 2.</strong>
RepoDriller is a project that extracts information from Git repositories. Its integration tests consumes lots of real Git repositories, each one with a different characteristic, e.g., one repository contains a merge commit, another repository contains a revert operation, etc.</p>
<p>Its tests look like what you see below:</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{

  <span class="hljs-comment">// arrange: specific repo</span>
  String path = <span class="hljs-string">&quot;test-repos/git-4&quot;</span>;

  <span class="hljs-comment">// act</span>
  TestVisitor visitor = <span class="hljs-keyword">new</span> TestVisitor();
  <span class="hljs-keyword">new</span> RepositoryMining()
  .in(GitRepository.singleProject(path))
  .through(Commits.all())
  .process(visitor)
  .mine();

  <span class="hljs-comment">// assert</span>
  Assert.assertEquals(<span class="hljs-number">3</span>, visitor.getVisitedHashes().size());
  Assert.assertTrue(visitor.getVisitedHashes().get(<span class="hljs-number">2</span>).equals(<span class="hljs-string">&quot;b8c2&quot;</span>));
  Assert.assertTrue(visitor.getVisitedHashes().get(<span class="hljs-number">1</span>).equals(<span class="hljs-string">&quot;375d&quot;</span>));
  Assert.assertTrue(visitor.getVisitedHashes().get(<span class="hljs-number">0</span>).equals(<span class="hljs-string">&quot;a1b6&quot;</span>));
}
</code></pre>
<p>Which test smell does this piece of code suffer from?</p>
<ol>
<li>Mystery guest</li>
<li>Condition logic in test</li>
<li>General fixture</li>
<li>Flaky test</li>
</ol>
<p><strong>Exercise 3.</strong>
In the code below, we present the source code of an automated test.</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flightMileage</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// setup fixture</span>
  <span class="hljs-comment">// exercise contructor</span>
  Flight newFlight = <span class="hljs-keyword">new</span> Flight(validFlightNumber);
  <span class="hljs-comment">// verify constructed object</span>
  assertEquals(validFlightNumber, newFlight.number);
  assertEquals(<span class="hljs-string">&quot;&quot;</span>, newFlight.airlineCode);
  assertNull(newFlight.airline);
  <span class="hljs-comment">// setup mileage</span>
  newFlight.setMileage(<span class="hljs-number">1122</span>);
  <span class="hljs-comment">// exercise mileage translater</span>
  <span class="hljs-keyword">int</span> actualKilometres = newFlight.getMileageAsKm();    
  <span class="hljs-comment">// verify results</span>
  <span class="hljs-keyword">int</span> expectedKilometres = <span class="hljs-number">1810</span>;
  assertEquals(expectedKilometres, actualKilometres);
  <span class="hljs-comment">// now try it with a canceled flight</span>
  newFlight.cancel();
  <span class="hljs-keyword">boolean</span> flightCanceledStatus = newFlight.isCancelled();
  assertFalse(flightCanceledStatus);
}
</code></pre>
<p>However, Joe, our new test specialist, believes this test is smelly and that it can be better written.
Which of the following could be Joe&apos;s main concern?</p>
<ol>
<li>The test contains code that may or may not be executed, making the test less readable.</li>
<li>It is hard to tell which of several assertions within the same test method will cause a test failure.</li>
<li>The test depends on external resources and has nondeterministic results depending on when/where it is run.</li>
<li>The test reader is not able to see the cause and effect between fixture and verification logic because part of it is done outside the test method.</li>
</ol>
<p><strong>Exercise 4.</strong>
See the test code below. What is the most likely test code smell that this piece of code presents?</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// webservice that communicates with the bank</span>
  BankWebService bank = <span class="hljs-keyword">new</span> BankWebService();

  User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;d.bergkamp&quot;</span>, <span class="hljs-string">&quot;nl123&quot;</span>);
  bank.authenticate(user);
  Thread.sleep(<span class="hljs-number">5000</span>); <span class="hljs-comment">// sleep for 5 seconds</span>

  <span class="hljs-keyword">double</span> balance = bank.getBalance();
  Thread.sleep(<span class="hljs-number">2000</span>);

  Payment bill = <span class="hljs-keyword">new</span> Payment();
  bill.setOrigin(user);
  bill.setValue(<span class="hljs-number">150.0</span>);
  bill.setDescription(<span class="hljs-string">&quot;Energy bill&quot;</span>);
  bill.setCode(<span class="hljs-string">&quot;YHG45LT&quot;</span>);

  bank.pay(bill);
  Thread.sleep(<span class="hljs-number">5000</span>);

  <span class="hljs-keyword">double</span> newBalance = bank.getBalance();
  Thread.sleep(<span class="hljs-number">2000</span>);

  <span class="hljs-comment">// new balance should be previous balance - 150</span>
  Assertions.assertEquals(newBalance, balance - <span class="hljs-number">150</span>);
}
</code></pre>
<ol>
<li>Flaky test.</li>
<li>Test code duplication.</li>
<li>Obscure test.</li>
<li>Long method.</li>
</ol>
<p><strong>Exercise 5.</strong>
In the code below, we show an actual test from Apache Commons Lang, a very popular open source Java library. This test focuses on the static <code>random()</code> method, which is responsible for generating random characters. A very interesting detail in this test is the comment: <em>Will fail randomly about 1 in 1000 times.</em></p>
<pre><code class="lang-java"><span class="hljs-comment">/**
 * Test homogeneity of random strings generated --
 * i.e., test that characters show up with expected frequencies
 * in generated strings.  Will fail randomly about 1 in 1000 times.
 * Repeated failures indicate a problem.
 */</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRandomStringUtilsHomog</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">final</span> String set = <span class="hljs-string">&quot;abc&quot;</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] chars = set.toCharArray();
    String gen = <span class="hljs-string">&quot;&quot;</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] counts = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] expected = {<span class="hljs-number">200</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span>};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">100</span>; i++) {
       gen = RandomStringUtils.random(<span class="hljs-number">6</span>,chars);
       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++) {
           <span class="hljs-keyword">switch</span> (gen.charAt(j)) {
               <span class="hljs-keyword">case</span> <span class="hljs-string">&apos;a&apos;</span>: {counts[<span class="hljs-number">0</span>]++; <span class="hljs-keyword">break</span>;}
               <span class="hljs-keyword">case</span> <span class="hljs-string">&apos;b&apos;</span>: {counts[<span class="hljs-number">1</span>]++; <span class="hljs-keyword">break</span>;}
               <span class="hljs-keyword">case</span> <span class="hljs-string">&apos;c&apos;</span>: {counts[<span class="hljs-number">2</span>]++; <span class="hljs-keyword">break</span>;}
               <span class="hljs-keyword">default</span>: {fail(<span class="hljs-string">&quot;generated character not in set&quot;</span>);}
           }
       }
    }
    <span class="hljs-comment">// Perform chi-square test with df = 3-1 = 2, testing at .001 level</span>
    assertTrue(<span class="hljs-string">&quot;test homogeneity -- will fail about 1 in 1000 times&quot;</span>,
        chiSquare(expected,counts) &lt; <span class="hljs-number">13.82</span>);
}
</code></pre>
<p>Which one of the following <strong>is incorrect</strong> about the test?</p>
<ol>
<li>The test is flaky because of the randomness that exists in generating characters.</li>
<li>The test checks for invalidly generated characters, and that characters are picked in the same proportion.</li>
<li>The method being static has nothing to do with its flakiness.</li>
<li>To avoid the flakiness, a developer could have mocked the random function. </li>
</ol>
<h2 id="references">References</h2>
<p>Test code best practices:</p>
<ul>
<li>Chapter 5 of Pragmatic Unit Testing in Java 8 with Junit. Langr, Hunt, and Thomas. Pragmatic Programmers, 2015.</li>
<li>Meszaros, G. (2007). xUnit test patterns: Refactoring test code. Pearson Education.</li>
</ul>
<p>Empirical studies:</p>
<ul>
<li>Pryce, N. Test Data Builders: an alternative to the Object Mother pattern. <a href="http://natpryce.com/articles/000714.html" target="_blank">http://natpryce.com/articles/000714.html</a>. Last accessed in March, 2020.</li>
<li>Bavota, G., Qusef, A., Oliveto, R., De Lucia, A., &amp; Binkley, D. (2012, September). An empirical analysis of the distribution of unit test smells and their impact on software maintenance. In 2012 28th IEEE International Conference on Software Maintenance (ICSM) (pp. 56-65). IEEE.</li>
</ul>
<p>Flaky tests:</p>
<ul>
<li>Luo, Q., Hariri, F., Eloussi, L., &amp; Marinov, D. (2014, November). An empirical analysis of flaky tests. In Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering (pp. 643-653). ACM. 
Authors&apos; version: <a href="http://mir.cs.illinois.edu/~eloussi2/publications/fse14.pdf" target="_blank">http://mir.cs.illinois.edu/~eloussi2/publications/fse14.pdf</a></li>
<li>Bell, J., Legunsen, O., Hilton, M., Eloussi, L., Yung, T., &amp; Marinov, D. (2018, May). DeFlaker: automatically detecting flaky tests. In Proceedings of the 40th International Conference on Software Engineering (pp. 433-444). ACM. 
Authors&apos; version: <a href="http://mir.cs.illinois.edu/legunsen/pubs/BellETAL18DeFlaker.pdf" target="_blank">http://mir.cs.illinois.edu/legunsen/pubs/BellETAL18DeFlaker.pdf</a></li>
<li>Lam, W., Oei, R., Shi, A., Marinov, D., &amp; Xie, T. (2019, April). iDFlakies: A Framework for Detecting and Partially Classifying Flaky Tests. In 2019 12th IEEE Conference on Software Testing, Validation and Verification (ICST) (pp. 312-322). IEEE. 
Authors&apos; version: <a href="http://taoxie.cs.illinois.edu/publications/icst19-idflakies.pdf" target="_blank">http://taoxie.cs.illinois.edu/publications/icst19-idflakies.pdf</a></li>
<li>Listfield, J. Where do our flaky tests come from?<br>Link: <a href="https://testing.googleblog.com/2017/04/where-do-our-flaky-tests-come-from.html" target="_blank">https://testing.googleblog.com/2017/04/where-do-our-flaky-tests-come-from.html</a>, 2017.</li>
<li>Micco, J. Flaky tests at Google and How We Mitigate Them.<br>Link: <a href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html" target="_blank">https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html</a>, 2017.</li>
<li>Fowler, M. Eradicating Non-Determinism in Tests. Link: <a href="https://martinfowler.com/articles/nonDeterminism.html" target="_blank">https://martinfowler.com/articles/nonDeterminism.html</a>, 2011.</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="tdd.html" class="navigation navigation-prev " aria-label="Previous page: Test-driven development">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../testing-into-context/" class="navigation navigation-next " aria-label="Next page: Testing in the context">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Test code quality and engineering","level":"5.1.5","depth":2,"next":{"title":"Testing in the context","level":"6.1","depth":1,"path":"chapters/testing-into-context/README.md","ref":"chapters/testing-into-context/README.md","articles":[{"title":"Web testing (soon)","level":"6.1.1","depth":2,"path":"chapters/testing-into-context/web-testing.md","ref":"chapters/testing-into-context/web-testing.md","articles":[]},{"title":"SQL testing","level":"6.1.2","depth":2,"path":"chapters/testing-into-context/sql-testing.md","ref":"chapters/testing-into-context/sql-testing.md","articles":[]},{"title":"Web services testing (soon)","level":"6.1.3","depth":2,"ref":"","articles":[]},{"title":"Mobile testing (soon)","level":"6.1.4","depth":2,"ref":"","articles":[]}]},"previous":{"title":"Test-driven development","level":"5.1.4","depth":2,"path":"chapters/pragmatic-testing/tdd.md","ref":"chapters/pragmatic-testing/tdd.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["hints","katex","ga"],"pluginsConfig":{"search":{},"hints":{"danger":"fa fa-exclamation-circle","info":"fa fa-info-circle","tip":"fa fa-mortar-board","working":"fa fa-wrench"},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"ga":{"configuration":"auto","token":"UA-154019382-1"},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"assets/css/website.css"}},"file":{"path":"chapters/pragmatic-testing/test-code-quality.md","mtime":"2020-05-26T13:58:42.505Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-05-26T14:13:38.642Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-ga/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

