\hypertarget{sql-testing}{%
\section{SQL Testing}\label{sql-testing}}

As we discussed in the \emph{Testing Pyramid} chapter, parts of our
system only make sense to be tested by means of integration testing. A
common case for integration testing are classes that talk to databases.
Business applications are often composed of many
\href{https://en.wikipedia.org/wiki/Data_access_object}{Data Access
Objects} (DAOs) that perform complex SQL queries. A lot of business
knowledge are encapsulated in these queries, requiring testers to spend
some energy in making sure that produce the expected outcomes.

In this chapter, we discuss:

\begin{itemize}
\tightlist
\item
  What to test in a SQL query?
\item
  How to write automated test cases for such queries
\item
  Challenges and best practices
\end{itemize}

This chapter expects the reader to have some basic knowledge on SQL
queries.

\hypertarget{what-to-test-in-a-sql-query}{%
\subsection{What to test in a SQL
query?}\label{what-to-test-in-a-sql-query}}

SQL is a robust language and contains a large number of different
functions that developers can make use of. Let us simplify and see
queries as a composition of predicates. See the following examples:

\begin{itemize}
\tightlist
\item
  \texttt{SELECT\ *\ FROM\ INVOICE\ WHERE\ VALUE\ \textless{}\ 50}
\item
  \texttt{SELECT\ *\ FROM\ INVOICE\ I\ JOIN\ CUSTOMER\ C\ ON\ I.CUSTOMER\_ID\ =\ C.ID\ WHERE\ C.COUNTRY\ =\ \textquotesingle{}NL\textquotesingle{}}
\item
  \texttt{SELECT\ *\ FROM\ INVOICE\ WHERE\ VALUE\ \textgreater{}\ 50\ AND\ VALUE\ \textless{}\ 200}
\end{itemize}

In these examples, \texttt{value\ \textless{}\ 50},
\texttt{i.customer\_id\ =\ c.id},
\texttt{c.country\ =\ \textquotesingle{}NL\textquotesingle{}}, and
\texttt{value\ \textgreater{}\ 50\ and\ value\ \textless{}\ 200} are the
predicates that compose the different queries. As a tester, a possible
criteria is to exercise the different predicates and check whether the
SQL query returns the expected results when predicates are evaluated to
different results.

Virtually all the testing techniques we have discussed in the
\emph{Testing Techniques} part of this book can be applied here:

\begin{itemize}
\tightlist
\item
  Specification-based testing: These SQL queries emerge out of a
  requirement. A tester can analyse the requirements and derive
  equivalent partitions that need to be tested.
\item
  Boundary analysis: Such programs have boundaries. Given that we can
  also expect boundaries to be places with a high bug probability,
  exercise them is therefore also important.
\item
  Structural testing: Structurally-speaking, SQL queries contain
  predicates, and a tester might use the SQL's structure to derive test
  cases.
\end{itemize}

Let us focus on structural testing. If we look close to the third
example, and try to make an analogy with what we discussed in structural
testing, we see that the SQL query contains a single branch
(\texttt{value\ \textgreater{}\ 50\ and\ value\ \textless{}\ 200}),
composed of two predicates (\texttt{value\ \textgreater{}\ 50} and
\texttt{value\ \textless{}\ 200}). This means that there are four
possible combinations of results in these two predicates: (TT), (TF),
(FT), (FF). A tester might aim at:

\begin{itemize}
\tightlist
\item
  Branch coverage: in this case, two tests, one that makes the overall
  decision to be evaluated to true, and one that makes the overall
  decision to be evaluated to false would be enough to achieve 100\%
  branch coverage.
\item
  Condition+Branch coverage: in this case, three tests would be enough
  to achieve 100\% condition+branch coverage, e.g., T1=150, T2=40,
  T3=250.
\end{itemize}

In \href{https://dl.acm.org/doi/pdf/10.1145/1147214.1147221}{A practical
guide to SQL white-box testing}, Tuya and colleague suggests five
guidelines for designing SQL tests:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Adopting MC/DC for SQL conditions.} Decisions happen at three
  places in a SQL query: \emph{join}, \emph{where} and \emph{having}
  conditions. Testers can make use of a criteria such as MC/DC to fully
  exercise its predicates.
\item
  \textbf{Adapting MC/DC for tackling with nulls}. Given that databases
  have a special way of handling/returning NULLs, any (coverage)
  criteria should be adapted to a three-valued logic (i.e., true, false,
  null). In other words, consider the possibility of values being null
  in your query.
\item
  \textbf{Category partitioning selected data}. SQL can be considered a
  sort of declarative specification, of which we can define partitions
  to be tested. Directly from their text:

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Rows that are retrieved: We include a test state to force the query
    to not select any row.
  \item
    Rows that are merged: The presence of unwanted duplicate rows in the
    output is a common failure in some queries. We include a test state
    in which identical rows are selected.
  \item
    Rows that are grouped: For each of the group-by columns, we design
    test states to obtain at least two different groups at the output,
    such that the value used for the grouping is the same, and all the
    other are different.
  \item
    Rows that are selected in a subquery: For each subquery, we include
    test states that return zero and more rows, with at least one null
    and two different values in the selected column.
  \item
    Values that participate in aggregate functions: For each aggregate
    function (excluding count), we include at least one test state in
    which the function computes two equal values and another one that is
    different.
  \item
    Other expressions: We also design test states for expressions
    involving the like predicate, date management, string management,
    data type conversions or other functions using category partitioning
    and boundary checking.
  \end{enumerate}
\item
  \textbf{Checking the outputs.} We should check not only the input
  domain, but also the output domain. SQL queries might return NULL in
  specific columns or empty sets, for example, which might make the rest
  of the program to break.
\item
  \textbf{Checking the database constraints}. Databases have
  constraints. Testers should make sure these constraints are indeed
  enforced by the database.
\end{enumerate}

As you can see, many things can go wrong in a SQL query. And it is part
of a tester's job to make sure it does not happen.

\{\% hint style=`tip' \%\} For interested readers, in the
\href{https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.424}{Full
predicate coverage for testing SQL database queries} paper, Tuya et
al.~propose a MC/DC criteria for SQL queries. \{\% endhint \%\}

\hypertarget{how-to-write-automated-test-cases-for-sql-queries}{%
\subsection{How to write automated test cases for SQL
queries}\label{how-to-write-automated-test-cases-for-sql-queries}}

We can make use of JUnit to write SQL tests. After all, all we need is
to (1) establish a connection with the database, (2) make sure the
database is in the right initial state, (3) fire a SQL query, (4) check
the output.

Imagine: * We have an \texttt{Invoice} table that is composed of a
\texttt{name} (varchar, length 100) and a \texttt{value} (double). * We
have an \texttt{InvoiceDao} class that makes use of any API to
communicate with the database. The precise API does not matter. * This
DAO performs three actions: \texttt{save()} that persists an invoice in
a database, \texttt{all()} which returns all invoices in the database,
and \texttt{allWithAtLeast} that returns all invoices with at least an
specified value. * \texttt{all()} runs the following SQL query:
\texttt{select\ *\ from\ invoice} * \texttt{allWithAtLeast()} runs:
\texttt{select\ *\ from\ invoice\ where\ value\ \textgreater{}=\ ?} *
\texttt{save()} runs
\texttt{insert\ into\ invoice\ (name,\ value)\ values\ (?,?)}. * You may
see a JDBC implementation of this \texttt{InvoiceDao} in our
\href{https://github.com/sttp-book/code-examples/blob/master/src/main/java/tudelft/mocks/invoice/InvoiceDao.java}{code
examples} repository.

Take a look at this rather long JUnit test snippet (which you can also
see in our
\href{https://github.com/sttp-book/code-examples/blob/master/src/test/java/tudelft/mocks/invoice/InvoiceDaoIntegrationTest.java}{code
examples} repository:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ InvoiceDaoIntegrationTest \{}

    \KeywordTok{private} \DataTypeTok{final}\NormalTok{ DatabaseConnection connection = }\KeywordTok{new} \FunctionTok{DatabaseConnection}\NormalTok{();}
    \KeywordTok{private} \DataTypeTok{final}\NormalTok{ InvoiceDao dao = }\KeywordTok{new} \FunctionTok{InvoiceDao}\NormalTok{(connection);}

    \AttributeTok{@BeforeEach}
    \DataTypeTok{void} \FunctionTok{cleanup}\NormalTok{() }\KeywordTok{throws} \BuiltInTok{SQLException}\NormalTok{ \{}
        \CommentTok{/**}
         \CommentTok{*}\NormalTok{ Let}\CommentTok{\textquotesingle{}}\NormalTok{s clean up the table before the test runs}\CommentTok{.}
         \CommentTok{*}\NormalTok{ That will avoid possible flaky tests}\CommentTok{.}
         \CommentTok{*}
         \CommentTok{*}\NormalTok{ Note that doing a single }\CommentTok{\textquotesingle{}}\NormalTok{truncate}\CommentTok{\textquotesingle{}}\NormalTok{ here seems simple and enough for this exercise}\CommentTok{.}
         \CommentTok{*}\NormalTok{ In large systems}\CommentTok{,}\NormalTok{ you will probably want to encapsulate the }\CommentTok{\textquotesingle{}}\NormalTok{reset database}\CommentTok{\textquotesingle{}}\NormalTok{ logic}
         \CommentTok{*}\NormalTok{ somewhere else}\CommentTok{.}\NormalTok{ Or even make use of specific frameworks for that}\CommentTok{.}
         \CommentTok{*/}
\NormalTok{        connection.}\FunctionTok{getConnection}\NormalTok{().}\FunctionTok{prepareStatement}\NormalTok{(}\StringTok{"truncate table invoice"}\NormalTok{).}\FunctionTok{execute}\NormalTok{();}

        \CommentTok{/**}
         \CommentTok{*}\NormalTok{ Maybe you also want to double check if the cleaning operation}
         \CommentTok{*}\NormalTok{ worked}\CommentTok{!}
         \CommentTok{*/}
        \BuiltInTok{List}\NormalTok{\textless{}Invoice\textgreater{} invoices = dao.}\FunctionTok{all}\NormalTok{();}
        \FunctionTok{assertThat}\NormalTok{(invoices).}\FunctionTok{isEmpty}\NormalTok{();}
\NormalTok{    \}}

    \AttributeTok{@AfterEach}
    \DataTypeTok{void} \FunctionTok{close}\NormalTok{() \{}
        \CommentTok{/**}
         \CommentTok{*}\NormalTok{ Closing up the connection might also be something you do}
         \CommentTok{*}\NormalTok{ at the end of each test}\CommentTok{.}
         \CommentTok{*}\NormalTok{ Or maybe only at the end of the entire test suite}\CommentTok{,}\NormalTok{ just to optimize}\CommentTok{.}
         \CommentTok{*} \CommentTok{(}\NormalTok{In practice}\CommentTok{,}\NormalTok{ you should also use some connection pool}\CommentTok{,}\NormalTok{ like C3P0}\CommentTok{,}
         \CommentTok{*}\NormalTok{ to handle connections}\CommentTok{)}
         \CommentTok{*/}
\NormalTok{        connection.}\FunctionTok{close}\NormalTok{();}
\NormalTok{    \}}

    \AttributeTok{@Test}
    \DataTypeTok{void} \FunctionTok{save}\NormalTok{() \{}
        \DataTypeTok{final}\NormalTok{ var inv1 = }\KeywordTok{new} \FunctionTok{InvoiceBuilder}\NormalTok{().}\FunctionTok{build}\NormalTok{();}
        \DataTypeTok{final}\NormalTok{ var inv2 = }\KeywordTok{new} \FunctionTok{InvoiceBuilder}\NormalTok{().}\FunctionTok{build}\NormalTok{();}

\NormalTok{        dao.}\FunctionTok{save}\NormalTok{(inv1);}

        \BuiltInTok{List}\NormalTok{\textless{}Invoice\textgreater{} afterSaving = dao.}\FunctionTok{all}\NormalTok{();}
        \FunctionTok{assertThat}\NormalTok{(afterSaving).}\FunctionTok{containsExactlyInAnyOrder}\NormalTok{(inv1);}

\NormalTok{        dao.}\FunctionTok{save}\NormalTok{(inv2);}
        \BuiltInTok{List}\NormalTok{\textless{}Invoice\textgreater{} afterSavingAgain = dao.}\FunctionTok{all}\NormalTok{();}
        \FunctionTok{assertThat}\NormalTok{(afterSavingAgain).}\FunctionTok{containsExactlyInAnyOrder}\NormalTok{(inv1, inv2);}
\NormalTok{    \}}

    \AttributeTok{@Test}
    \DataTypeTok{void} \FunctionTok{atLeast}\NormalTok{() \{}
        \DataTypeTok{int}\NormalTok{ value = }\DecValTok{50}\NormalTok{;}

        \CommentTok{/**}
         \CommentTok{*}\NormalTok{ Explore the boundary}\CommentTok{:}\NormalTok{ value }\CommentTok{\textgreater{}=}\NormalTok{ x}
         \CommentTok{*}\NormalTok{ On point }\CommentTok{=}\NormalTok{ x}
         \CommentTok{*}\NormalTok{ Off point }\CommentTok{=}\NormalTok{ x}\CommentTok{{-}1}
         \CommentTok{*}\NormalTok{ In point }\CommentTok{=}\NormalTok{ x }\CommentTok{+} \CommentTok{1} \CommentTok{(}\NormalTok{not really necessary}\CommentTok{,}\NormalTok{ but it}\CommentTok{\textquotesingle{}}\NormalTok{s cheap}\CommentTok{,}\NormalTok{ and makes the}
         \CommentTok{*}\NormalTok{   test strategy easier to comprehend}\CommentTok{)}
         \CommentTok{*/}
        \DataTypeTok{final}\NormalTok{ var inv1 = }\KeywordTok{new} \FunctionTok{InvoiceBuilder}\NormalTok{().}\FunctionTok{withValue}\NormalTok{(value {-} }\DecValTok{1}\NormalTok{).}\FunctionTok{build}\NormalTok{();}
        \DataTypeTok{final}\NormalTok{ var inv2 = }\KeywordTok{new} \FunctionTok{InvoiceBuilder}\NormalTok{().}\FunctionTok{withValue}\NormalTok{(value).}\FunctionTok{build}\NormalTok{();}
        \DataTypeTok{final}\NormalTok{ var inv3 = }\KeywordTok{new} \FunctionTok{InvoiceBuilder}\NormalTok{().}\FunctionTok{withValue}\NormalTok{(value + }\DecValTok{1}\NormalTok{).}\FunctionTok{build}\NormalTok{();}

\NormalTok{        dao.}\FunctionTok{save}\NormalTok{(inv1);}
\NormalTok{        dao.}\FunctionTok{save}\NormalTok{(inv2);}
\NormalTok{        dao.}\FunctionTok{save}\NormalTok{(inv3);}

        \BuiltInTok{List}\NormalTok{\textless{}Invoice\textgreater{} afterSaving = dao.}\FunctionTok{allWithAtLeast}\NormalTok{(value);}
        \FunctionTok{assertThat}\NormalTok{(afterSaving).}\FunctionTok{containsExactlyInAnyOrder}\NormalTok{(inv2, inv3);}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Let us understand it:

\begin{itemize}
\tightlist
\item
  Before each test, a clean up operation happens. We clean the entire
  database to make sure our tests will not be flaky. It is easy to
  imagine that, if a database has unkwnown data, a SQL query will return
  unexpected results. Note that, in here, we are doing a simple
  \texttt{truncate\ table}. In more complex systems, you might want to
  extract this ``reset database'' logic to an specialized class (or even
  to make use of framework).
\item
  After each class, we close the connection, to avoid connection leaks.
  In this example, a simple \texttt{Connection\#close} suffices. In real
  life, you might want to use some professional connection pool (not
  only for your test code, but also for your production code!)
\item
  The \texttt{save()} test method exercises both \texttt{save()} and
  \texttt{all()} methods. It inserts values to the database and ensures
  they are persisted correctly afterwards.
\item
  The \texttt{atLeast} exercises the \texttt{allWithAtLeast} method.
  Note how it also exercises the boundaries of the
  \texttt{value\textgreater{}?} condition.
\item
  Observe how test data builders (in this case, exemplified by the
  \texttt{InvoiceBuilder} class) helps us in quickly building test data.
\end{itemize}

This test suite might be considered good enough for the current
\texttt{InvoiceDao} class. Note that, by basically applying all the
ideas we have seen before, we were able to write good SQL testing
without much costs.

\hypertarget{challenges-and-best-practices}{%
\subsection{Challenges and best
practices}\label{challenges-and-best-practices}}

The example above was quite simple. Challenges might emerge once your
SQL queries are highly complex. Some tips:

\begin{itemize}
\tightlist
\item
  \textbf{Make use of test data builders.} They will help you to quickly
  build the data structures you need.
\item
  \textbf{Make use of good assertions APIs.} Asserting was easy in the
  example above as AssertJ makes our life easier.
\item
  \textbf{Minimize the required data}. Make sure the input data is
  minimized. You do not want to have to load hundreds of thousands of
  elements to exercise your SQL query (maybe you will want to do this to
  exercise other features of your database, like speed, but that is not
  the case here).
\item
  \textbf{Build good test infrastructure}. In our example, it was simple
  to open a connection, to reset the database state, and etc, but that
  might become more complicated (or lenghty) once your database schema
  gets complicated. Invest on a test infrastructure to facilitate your
  SQL testing.
\item
  \textbf{Take into consideration the schema evolution}. In real life,
  database schemas evolve quite fast. Make sure your test suite is
  resilient towards these changes (i.e., if an evolution should not
  break the test suite, it does not; if an evolution should break the
  test suite, it does break the test suite).
\item
  \textbf{Consider an in-memory database}. You should decide whether
  your tests will communicate with a ``real'' database (i.e., the same
  database of your production environment) or a simpler database (e.g.,
  an in-memory database). As always, both sides have advantages and
  disadvantages. Using a the same database as in production makes your
  tests more realistic, but probably slower than if you use an in-memory
  database.
\end{itemize}

\hypertarget{references}{%
\subsection{References}\label{references}}

\begin{itemize}
\tightlist
\item
  Tuya, Javier, M. José Suárez-Cabal, and Claudio De La Riva. ``A
  practical guide to SQL white-box testing.'' ACM SIGPLAN Notices 41,
  no. 4 (2006): 36-41.
\end{itemize}
