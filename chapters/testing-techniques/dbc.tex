\hypertarget{design-by-contracts}{%
\section{Design by Contracts}\label{design-by-contracts}}

\emph{Can code test itself?} In this chapter, we discuss what design by
contracts and property-based testing are.

\hypertarget{self-testing}{%
\subsection{Self Testing}\label{self-testing}}

A self testing system is, in principle, a system that tests itself. This
may sound a bit weird, so let us take a step back first.

The way we tested systems so far was by creating separate classes for
the tests. The production code and test code were completely separated.
The test suite (consisting of the test classes) exercises and then
observes the system under test to check whether it is acting correctly.
If the system does something that is not expected by the test suite, the
test suite fails. The code in the test suite is completely redundant. It
does not add any behaviour to the system.

With self-testing, we ``move'' part of the test suite into the system
itself. These assertions we insert into production code allows the
system to check if it is running correctly by itself. We do not have to
run the test suite, but instead the system can check (part of) its
behaviour during its normal execution. Like with the test suite, if
anything is not acting as expected, an error will be thrown. In software
testing, the self-tests are used as an additional check in the system
complementary to the test suite.

\hypertarget{assertions}{%
\subsubsection{Assertions}\label{assertions}}

The simplest form of this self-testing is the \emph{assertion}. An
assertion is a Boolean expression at a specific point in a program which
will be true unless there is a bug in the program. In other words, an
assertion states that a certain condition has to be true at the time the
assertion is executed.

In Java, to make an assertion we use the \texttt{assert} keyword:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{assert \textless{}condition\textgreater{} : }\StringTok{"\textless{}message\textgreater{}"}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

The \texttt{assert} keyword checks if the
\texttt{\textless{}condition\textgreater{}} is true. If it is, nothing
happens. The program just continues its execution as everything is
according to plan. However, if the
\texttt{\textless{}condition\textgreater{}} yields false, the
\texttt{assert} throws an \texttt{AssertionError}.

Let us walk through an example. Take the implementation of a Stack, of
which we just show the \texttt{pop} method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ MyStack \{}
  \KeywordTok{public} \BuiltInTok{Element} \FunctionTok{pop}\NormalTok{() \{}
\NormalTok{    assert }\FunctionTok{count}\NormalTok{() \textgreater{} }\DecValTok{0}\NormalTok{ : }\StringTok{"The stack does not have any elements to pop"}\NormalTok{;}

    \CommentTok{// ... actual method body ...}

\NormalTok{    assert }\FunctionTok{count}\NormalTok{() == oldCount {-} }\DecValTok{1}\NormalTok{ : }\StringTok{"Size of stack did not decrease by one"}\NormalTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In this method, we check if a condition holds at the start: the stack
should have at least one element. Then, after the actual method, we
check whether the count is now one lower than before popping.

These conditions are also known as \emph{pre- and post-conditions}. We
cover these in the following section.

\{\% hint style=`tip' \%\} The assertion's message is optional, but can
be very helpful for debugging. Always include a message that describes
what is going wrong if the assertion is failing. \{\% endhint \%\}

In Java, asserts can be enabled or disabled. If the asserts are
disabled, they will never throw an \texttt{AssertionError} even if their
conditions are false. Java's default configuration is to disable the
assertions.

To enable the asserts, we have to run Java with a special argument in
one of these two ways: \texttt{java\ -enableassertions} or
\texttt{java\ -ea}. When using Maven or IntelliJ, the assertions are
enabled automatically when running tests. With Eclipse or Gradle, we
have to enable it ourselves.

\{\% set video\_id = ``Tnm0qwsEiyU'' \%\} \{\% include
``/includes/youtube.md'' \%\}

Note how assertions play the role of test oracles here, but in a
slightly different way. Just to remember: oracles inform us whether the
software behaved correctly.

So far, we only used ``value comparison'' as oracle. Given an input that
we devised, we knew what output to expect. For example, in a program
that returns the square root of a number, given \texttt{n=4}, the value
we expect as output is \texttt{2}. Instead of focusing on a specific
instance, like we did so far, property checks, like the ones we are
going to see in the remainder of this chapter, are more general rules
(properties) that we assert on our code. For example, a program that,
given \[n\], returns \[n^2\], has a property that it should never return
a negative number.

Assertions also serve as an extra safety measure. If it is crucial that
a system runs correctly, we can use the asserts to add some additional
testing during the system's execution.

Note that assertions do not replace unit tests. Assertions are often of
a more general nature. We still need the specific cases in the unit
tests. A combination of both is what we desire.

\{\% set video\_id = ``OD0BY8GQs9M'' \%\} \{\% include
``/includes/youtube.md'' \%\}

\hypertarget{pre--and-post-conditions}{%
\subsection{Pre- and Post-conditions}\label{pre--and-post-conditions}}

We briefly mentioned pre- and post-condition in an example. Let us
formalise the idea and see how to create good pre- and post-conditions
and their influence on the code that we are writing.

Tony Hoare pioneered reasoning about programs with assertions, proposing
what is now called \textbf{Hoare Triples}. A Hoare Triple consists of a
set of pre-conditions \[\{ P \}\], a program \[A\] and a set of
post-conditions \[\{ Q \}\] We can express the Hoare Triple as follows:
\[\{ P \}\ A\ \{ Q \}\]. This can be read as: if we know that \[P\]
holds, and we execute \[A\], then, we end up in a state where \[Q\]
holds. If there are no pre-conditions, i.e., no assumptions needed for
the execution of \[A\], we can simply set \[P\] to true.

In a Hoare Triple, the \[A\] can be a single statement or a whole
program. We will take \[A\] to be a method. As such, \[P\] and \[Q\] are
the pre- and post-condition of the method \[A\] respectively. Now we can
write the Hoare Triple as:
\[\{ \mathit{pre-conditions} \}\ \mathit{method}\ \{ \mathit{post-conditions} \}\].

\hypertarget{pre-conditions}{%
\subsubsection{Pre-conditions}\label{pre-conditions}}

When writing a method, each condition that needs to hold for the method
to successfully execute can be a pre-condition. These pre-conditions can
be turned into assertions.

Suppose a class that keeps track of one's favourite books. Let us define
some pre-conditions for the \texttt{merge} method. The method adds the
given books to the list of favourite books and then sends some
notification to, e.g., a phone.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ FavoriteBooks \{}
  \BuiltInTok{List}\NormalTok{\textless{}}\BuiltInTok{Book}\NormalTok{\textgreater{} favorites;}

  \CommentTok{// ...}

  \KeywordTok{public} \DataTypeTok{void} \FunctionTok{merge}\NormalTok{(}\BuiltInTok{List}\NormalTok{\textless{}}\BuiltInTok{Book}\NormalTok{\textgreater{} books) \{}
\NormalTok{    favorites.}\FunctionTok{addAll}\NormalTok{(books);}
\NormalTok{    pushNotification.}\FunctionTok{booksAdded}\NormalTok{(books);}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

When creating pre-conditions, testers have to think about what needs to
hold to let the method execute. We can focus on the parameter
\texttt{books} first. It cannot be \texttt{null}, because then the
\texttt{addAll} method will throw a \texttt{NullPointerException}. It
should also not be empty, because then no books will be added to the
favourites. Finally, there has to be at least a single book that is not
yet in the favourites list.

Now let us take a look at \texttt{favorites}. This also cannot be
\texttt{null} because then it is not possible to call \texttt{addAll} on
favourites.

This gives us 4 pre-conditions and, thus, 4 assertions in the method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ FavoriteBooks \{}
  \CommentTok{// ...}

  \KeywordTok{public} \DataTypeTok{void} \FunctionTok{merge}\NormalTok{(}\BuiltInTok{List}\NormalTok{\textless{}}\BuiltInTok{Book}\NormalTok{\textgreater{} books) \{}
\NormalTok{    assert books != }\KeywordTok{null}\NormalTok{ : }\StringTok{"The list of books is null"}\NormalTok{;}
\NormalTok{    assert favorites != }\KeywordTok{null}\NormalTok{ : }\StringTok{"The favorites list is null"}\NormalTok{;}
\NormalTok{    assert !books.}\FunctionTok{isEmpty}\NormalTok{() : }\StringTok{"There are no books in the given list"}\NormalTok{;}
\NormalTok{    assert !favorites.}\FunctionTok{containsAll}\NormalTok{(books) : }\StringTok{"All books in the given list are already in favorites"}\NormalTok{;}

\NormalTok{    favorites.}\FunctionTok{addAll}\NormalTok{(books);}
\NormalTok{    pushNotification.}\FunctionTok{booksAdded}\NormalTok{(books);}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The number of assumptions made before a method can be executed (and,
with that, the number of pre-conditions) is a design choice.

One might want to \emph{weaken the pre-conditions}, so that the method
accepts/is able to handle more situations. To that aim, we can remove a
pre-condition as the method itself can handle the situation where the
pre-condition would be false. This makes the method more generally
applicable, but also increases its complexity. The method always has to
check some extra things to handle the cases that could have been
pre-conditions. Finding the balance between the number of pre-conditions
and complexity of the method is part of designing the system.

We can remove some of the pre-conditions of the \texttt{merge} method by
adding some if-statements to the method. First, we can try to remove the
\texttt{!books.isEmpty()} assertions. This means that the method
\texttt{merge} has to handle empty \texttt{books} lists itself.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ FavoriteBooks \{}
  \CommentTok{// ...}

  \KeywordTok{public} \DataTypeTok{void} \FunctionTok{merge}\NormalTok{(}\BuiltInTok{List}\NormalTok{\textless{}}\BuiltInTok{Book}\NormalTok{\textgreater{} books) \{}
\NormalTok{    assert books != }\KeywordTok{null}\NormalTok{ : }\StringTok{"The list of books is null"}\NormalTok{;}
\NormalTok{    assert favorites != }\KeywordTok{null}\NormalTok{ : }\StringTok{"The favorites list is null"}\NormalTok{;}
\NormalTok{    assert !favorites.}\FunctionTok{containsAll}\NormalTok{(books) : }\StringTok{"All books in the given list are already in favorites"}\NormalTok{;}

    \KeywordTok{if}\NormalTok{ (!books.}\FunctionTok{isEmpty}\NormalTok{()) \{}
\NormalTok{      favorites.}\FunctionTok{addAll}\NormalTok{(books);}
\NormalTok{      pushNotification.}\FunctionTok{booksAdded}\NormalTok{(books);}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

By generalising the \texttt{merge} method, we have removed one of the
pre-conditions.

We can even remove the \texttt{!favorites.containsAll(books)} assertion
by adding some more functionality to the method.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ FavoriteBooks \{}
  \CommentTok{// ...}

  \KeywordTok{public} \DataTypeTok{void} \FunctionTok{merge}\NormalTok{(}\BuiltInTok{List}\NormalTok{\textless{}}\BuiltInTok{Book}\NormalTok{\textgreater{} books) \{}
\NormalTok{    assert books != }\KeywordTok{null}\NormalTok{ : }\StringTok{"The list of books is null"}\NormalTok{;}
\NormalTok{    assert favorites != }\KeywordTok{null}\NormalTok{ : }\StringTok{"The favorites list is null"}\NormalTok{;}

    \BuiltInTok{List}\NormalTok{\textless{}}\BuiltInTok{Book}\NormalTok{\textgreater{} newBooks = books.}\FunctionTok{removeAll}\NormalTok{(favorites);}

    \KeywordTok{if}\NormalTok{ (!newBooks.}\FunctionTok{isEmpty}\NormalTok{()) \{}
\NormalTok{      favorites.}\FunctionTok{addAll}\NormalTok{(newBooks);}
\NormalTok{      pushNotification.}\FunctionTok{booksAdded}\NormalTok{(newBooks);}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note that, although we increased the complexity of the method by
removing some of its pre-conditions and dealing with these cases in the
implementation, the method is now also easier to be called by clients.
After all, the method has less pre-conditions to be considered.

\hypertarget{post-conditions}{%
\subsubsection{Post-conditions}\label{post-conditions}}

The pre-conditions of a method hold when the method is called. At the
end of the method, its \textbf{post-conditions} should hold. In other
words, the post-conditions formalise the effects that a method
guarantees to have when it is done with its execution.

The \texttt{merge} method of the previous examples does two things.
First, it adds the new books to the \texttt{favorites} list. Let us turn
this into a Boolean expression, so we can formulate this as a
post-condition.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ FavoriteBooks \{}
  \CommentTok{// ...}

  \KeywordTok{public} \DataTypeTok{void} \FunctionTok{merge}\NormalTok{(}\BuiltInTok{List}\NormalTok{\textless{}}\BuiltInTok{Book}\NormalTok{\textgreater{} books) \{}
\NormalTok{    assert books != }\KeywordTok{null}\NormalTok{ : }\StringTok{"The list of books is null"}\NormalTok{;}
\NormalTok{    assert favorites != }\KeywordTok{null}\NormalTok{ : }\StringTok{"The favorites list is null"}\NormalTok{;}

    \BuiltInTok{List}\NormalTok{\textless{}}\BuiltInTok{Book}\NormalTok{\textgreater{} newBooks = books.}\FunctionTok{removeAll}\NormalTok{(favorites);}

    \KeywordTok{if}\NormalTok{ (!newBooks.}\FunctionTok{isEmpty}\NormalTok{()) \{}
\NormalTok{      favorites.}\FunctionTok{addAll}\NormalTok{(newBooks);}
\NormalTok{      pushNotification.}\FunctionTok{booksAdded}\NormalTok{(newBooks);}
\NormalTok{    \}}

\NormalTok{    assert favorites.}\FunctionTok{containsAll}\NormalTok{(books) : }\StringTok{"Not all books were added to favorites"}\NormalTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The other effect of the method is the notification that is sent.
Unfortunately, we cannot easily formalise this as a post-condition. In a
test suite, we would probably mock the \texttt{pushNotification} and
then use \texttt{Mockito.verify} to verify that \texttt{booksAdded} was
called.

It is important to realise that these post-conditions only have to hold
if the pre-conditions held when the method was called. \textbf{In other
words, if the method's pre-conditions were not fully satisfied, the
method might not guarantee its post-conditions.}

You also saw in the example that we could not really write assertions
for some of the post-conditions of the method. Post-conditions (and
pre-conditions for that matter) might not cover all the possible
effects; however, hopefully they do cover a relevant subset of the
possible behaviour.

For complex methods, the post-conditions also become more complex. That
is actually another reason for keeping the method simple. Suppose a
method with multiple return points. That might require the developer to
define different post-conditions for each of its different outcomes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if}\NormalTok{ (A) \{}
  \CommentTok{// ...}
  \KeywordTok{if}\NormalTok{ (B) \{}
    \CommentTok{// ...}
\NormalTok{    assert PC1;}
    \KeywordTok{return}\NormalTok{ ...;}
\NormalTok{  \} }\KeywordTok{else}\NormalTok{ \{}
    \CommentTok{// ...}
\NormalTok{    assert PC2;}
    \KeywordTok{return}\NormalTok{ ...;}
\NormalTok{  \}}
\NormalTok{\}}
\CommentTok{// ...}
\NormalTok{assert PC3;}
\KeywordTok{return}\NormalTok{ ...;}
\end{Highlighting}
\end{Shaded}

The method above has three conditions and three different return
statements. This also gives us three post-conditions. In the example, if
\texttt{A} and \texttt{B} are true, post-condition 1 should hold. If
\texttt{A} is true but \texttt{B} is false, post-condition 2 should
hold. Finally, if \texttt{A} is false, post-condition 3 should hold.

The placing of these post-conditions now becomes quite important, so the
whole method is becoming rather complex with the post-conditions.
Refactoring the method so that it has just a single return statement
with a general post-condition is advisable. Otherwise, the
post-condition essentially becomes a disjunction of propositions. Each
return statement forms a possible post-condition (proposition) and the
method guarantees that one of these post-conditions is met.

\hypertarget{how-do-weak-pre-conditions-affect-the-post-conditions}{%
\subsubsection{How do weak pre-conditions affect the
post-conditions?}\label{how-do-weak-pre-conditions-affect-the-post-conditions}}

Based on what we saw about pre- and post-conditions, we can come up with
a few rules:

\begin{itemize}
\item
  The weaker the pre-conditions, the more situations a method is able to
  handle, and the less thinking the client needs to do. However, with
  weak pre-conditions, the method will always have to do the checking.
\item
  The post-conditions are only guaranteed if the pre-conditions held; if
  not, the outcome can be anything. With weak pre-conditions the method
  might have to handle different situations, leading to multiple
  post-conditions guarded by conditions over the inputs or the program
  state.
\end{itemize}

\{\% set video\_id = ``LCJ91VSS3Z8'' \%\} \{\% include
``/includes/youtube.md'' \%\}

\hypertarget{invariants}{%
\subsection{Invariants}\label{invariants}}

We have seen that pre-conditions should hold before a method's execution
and post-conditions should hold after a method's execution. Now we move
to conditions that always have to hold, before and after a method's
execution. These conditions are called \textbf{invariants}. An invariant
is thus a condition that holds throughout the entire lifetime of a
system, an object, or a data structure.

In terms of implementation, a simple way of using invariants is by
creating a ``checker'' method. This method will go through the data
structure/object/system and will assert whether the invariants hold. If
an invariant does not hold, it will then throw an
\texttt{AssertionError}. For simpler invariants, it is common to see a
Boolean method that checks the invariants of the
structure/object/system.

Suppose we have a binary tree data structure. An invariant for this data
structure would be that when a parent points to a child, then the child
should point to this parent.

We can make a method that checks if this representation is correct in
the given binary tree.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{checkRep}\NormalTok{(BinaryTree tree) \{}
\NormalTok{  BinaryTree left = tree.}\FunctionTok{getLeft}\NormalTok{();}
\NormalTok{  BinaryTree right = tree.}\FunctionTok{getRight}\NormalTok{();}

  \FunctionTok{assert}\NormalTok{ (left == }\KeywordTok{null}\NormalTok{ || left.}\FunctionTok{getParent}\NormalTok{() == tree) \&\&}
\NormalTok{      (right == }\KeywordTok{null}\NormalTok{ || right.}\FunctionTok{getParent}\NormalTok{() == tree) :}
      \StringTok{"A child does not point to the correct parent"}\NormalTok{;}

  \KeywordTok{if}\NormalTok{ (left != }\KeywordTok{null}\NormalTok{) \{}
    \FunctionTok{checkRep}\NormalTok{(left);}
\NormalTok{  \}}
  \KeywordTok{if}\NormalTok{ (right != }\KeywordTok{null}\NormalTok{) \{}
    \FunctionTok{checkRep}\NormalTok{(right);}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In \texttt{checkRep()}, we first check if the children nodes of the
current node are pointing to this node as parent. Then, we continue by
checking the child nodes the same way we checked the current node.

\hypertarget{class-invariants}{%
\subsubsection{Class invariants}\label{class-invariants}}

In Object-Oriented Programming, these checks can also be applied at the
class-level. This gives us \textbf{class invariants}. A class invariant
ensures that its conditions will be true throughout the entire lifetime
of the object.

The first time a class invariant should be true is right after its
construction (i.e., when the constructor method is done). The class
invariant should also hold after each public method invocation.
Moreover, methods can assume that, when they start, the class invariant
holds.

A private method invoked by a public method can leave the object with
the class invariant being false. However, the public method that invoked
the private method should then fix this and end with the class invariant
again being true.

This is all formalised by Bertrand Meyer as: \emph{``The class invariant
indicates that a proposition P can be a class invariant if it holds
after construction, and before and after any call to a public method
assuming that the public methods are called with their pre-conditions
being true.''}

To implement a simple class invariant in Java, we can use the Boolean
method that checks if the representation is okay. We usually call this
method \texttt{invariant}. We then assert the return value of this
method after the constructor, and before and after each public method.
In these public methods, the only pre-conditions and post-conditions
that have to hold additionally are the ones that are not in the
invariant.

Let us return to the \texttt{FavoriteBooks} with the \texttt{merge}
method. We had a pre-condition saying that \texttt{favorites\ !=\ null}.
Given that this should always be true, we can turn it into a class
invariant. Additionally, we can add the condition that
\texttt{pushNotification\ !=\ null}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ FavoriteBooks \{}
  \BuiltInTok{List}\NormalTok{\textless{}}\BuiltInTok{Book}\NormalTok{\textgreater{} favorites;}
\NormalTok{  Listener pushNotification;}

  \KeywordTok{public} \FunctionTok{FavoriteBooks}\NormalTok{(...) \{}
\NormalTok{    favorites = ...;}
\NormalTok{    pushNotification = ...;}

    \CommentTok{// ...}

\NormalTok{    assert }\FunctionTok{invariant}\NormalTok{() : }\StringTok{"Invariant does not hold"}\NormalTok{;}
\NormalTok{  \}}

  \KeywordTok{protected} \DataTypeTok{boolean} \FunctionTok{invariant}\NormalTok{() \{}
    \KeywordTok{return}\NormalTok{ favorites != }\KeywordTok{null}\NormalTok{ \&\& pushNotification != }\KeywordTok{null}\NormalTok{;}
\NormalTok{  \}}

  \KeywordTok{public} \DataTypeTok{void} \FunctionTok{merge}\NormalTok{(}\BuiltInTok{List}\NormalTok{\textless{}}\BuiltInTok{Book}\NormalTok{\textgreater{} books) \{}
\NormalTok{    assert }\FunctionTok{invariant}\NormalTok{() : }\StringTok{"Invariant does not hold"}\NormalTok{;}

    \CommentTok{// Remaining pre{-}conditions}
\NormalTok{    assert books != }\KeywordTok{null}\NormalTok{ : }\StringTok{"The list of books is null"}\NormalTok{;}

    \BuiltInTok{List}\NormalTok{\textless{}}\BuiltInTok{Book}\NormalTok{\textgreater{} newBooks = books.}\FunctionTok{removeAll}\NormalTok{(favorites);}

    \KeywordTok{if}\NormalTok{ (!newBooks.}\FunctionTok{isEmpty}\NormalTok{()) \{}
\NormalTok{      favorites.}\FunctionTok{addAll}\NormalTok{(newBooks);}
\NormalTok{      pushNotification.}\FunctionTok{booksAdded}\NormalTok{(newBooks);}
\NormalTok{    \}}

    \CommentTok{// Remaining post{-}conditions}
\NormalTok{    assert favorites.}\FunctionTok{containsAll}\NormalTok{(books) : }\StringTok{"Not all books were added to favorites"}\NormalTok{;}

\NormalTok{    assert }\FunctionTok{invariant}\NormalTok{() : }\StringTok{"Invariant does not hold"}\NormalTok{;}
\NormalTok{  \}}

\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note that the \texttt{invariant} method checks the two conditions. We
call \texttt{invariant} before and after \texttt{merge} and we only
assert the pre- and post-conditions that are not covered in the
\texttt{invariant} method. We also assert the result of the
\texttt{invariant} method at the end of the constructor.

\{\% hint style=`tip' \%\} When handling more complicated invariants, we
can split the invariant into more methods. Then we use these methods in
the \texttt{invariant} method. \{\% endhint \%\}

\{\% set video\_id = ``T5kwU91W07s'' \%\} \{\% include
``/includes/youtube.md'' \%\}

\hypertarget{design-by-contracts-1}{%
\subsection{Design by Contracts}\label{design-by-contracts-1}}

Suppose a client system and a server system. The client makes use of the
server's API. The client and server are bound by a \emph{contract}. The
server does its job as long as its methods are used properly by the
client. This relates strongly to the pre- and post-conditions that we
discussed earlier. The client has to use the server's methods in a way
that their pre-conditions hold. The server then guarantees that the
post-conditions will hold after the method call, i.e., makes sure the
method delivers what it promises.

Note how the pre- and post-conditions of the server forms a contract
between the server and the client. Designing a system following such
contracts is called what we call \textbf{Design by Contracts}. In such
design, contracts are represented by interfaces. These interfaces are
used by the client and implemented by the server. The following UML
diagram illustrates it:

\begin{figure}
\centering
\includegraphics{img/design-by-contracts/dbc_uml.svg}
\caption{Design by Contracts UML diagram}
\end{figure}

\hypertarget{subcontracting}{%
\subsubsection{Subcontracting}\label{subcontracting}}

Imagine now an interface. This interface has its own pre- and
post-conditions. Now, what happens to these conditions when we create
another implementation of this interface (i.e., a class that implements
the interface, or a class that extends some base class)?

In the UML diagram above, we see that the implementation can have
different pre-, post-conditions, and invariants than its base interface.

In terms of pre-conditions, the new implementation must be able to work
with the pre-conditions that were specified in the interface. After all,
the interface is the only thing the client sees of the system. The
implementation cannot add any pre-conditions to the server's
pre-conditions. In terms of strength, we now know that \[P'\] has to be
\textbf{weaker} than (or as weak as) \[P\].

The post-condition works the other way around. The implementation must
do at least the same work as the interface, but is allowed to do a bit
more. Therefore, \[Q'\] should be \textbf{stronger} than (or as strong
as) \[Q\].

Finally, the interface guarantees that the invariant always holds. Then,
the implementation should also guarantee that at least the interface's
invariant holds. So, \[I'\] should be \textbf{stronger} than (or as
strong as) \[I\].

In short, using the notation of the UML diagram:

\begin{itemize}
\tightlist
\item
  \[P'\] \textbf{weaker} than \[P\]
\item
  \[Q'\] \textbf{stronger} than \[Q\]
\item
  \[I'\] \textbf{stronger} than \[I\]
\end{itemize}

The subcontract (the implementation) requires no more and ensures no
less than the actual contract (the interface).

\{\% set video\_id = ``aA29jZYdJos'' \%\} \{\% include
``/includes/youtube.md'' \%\}

\hypertarget{liskov-substitution-principle}{%
\subsubsection{Liskov Substitution
Principle}\label{liskov-substitution-principle}}

The subcontracting follows the general notion of behavioural subtyping,
proposed by Barbara Liskov. The behavioural subtyping states that if we
have a class \texttt{T} and this class has some sub-classes, the clients
or users of class \texttt{T} should be able to choose any of
\texttt{T}'s sub-classes. This notion of behavioural subtyping is now
known as the \textbf{Liskov Substitution Principle (LSP)}.

In other words, the LSP states that if you use a class, you should be
able to replace this class by one of its subclasses. The sub-contracting
we discussed earlier is just a formalisation of this principle. Proper
class hierarchies follow the Liskov Substitution Principle. Keep the LSP
in mind when designing and implementing a software system.

How can we test that our classes follow the LSP? To test the LSP, we
have to make some test cases for the public methods of the super class
and execute these tests with all its subclasses. We could just create
the same tests to each of the subclasses' test suites. However, this
leads to a lot of code duplication in the test code, which we would like
to avoid.

In Java, the List interface is implemented by various sub-classes, such
as \texttt{ArrayList} and \texttt{LinkedList}. Creating the tests for
each of the sub-classes separately will result in the following
structure.

\begin{figure}
\centering
\includegraphics{img/design-by-contracts/examples/subclass_test.svg}
\caption{Test classes architecture}
\end{figure}

The ArrayList and LinkedList will behave the same for the methods
defined in List. Therefore, there will be duplicate tests for these
methods.

To avoid this code duplication, we can create a test suite just for the
super class. This test suite tests just the public methods of the super
class. The tests in this test suite should then be executed for each of
the sub-classes of the super class. This can be done by making the test
classes extend the ``super test class''. The ``sub test class'' will
have all the common tests defined in the ``super test class'' and its
own specific tests.

This is how the test suite looks like:

\begin{figure}
\centering
\includegraphics{img/design-by-contracts/examples/parallel_architecture.svg}
\caption{Parallel Class Hierarchy}
\end{figure}

Here, the \texttt{ArrayListTest} and \texttt{LinkedListTest} extend the
\texttt{ListTest}. List is an interface, so the \texttt{ListTest} should
be abstract. We cannot instantiate a \texttt{List} itself, so we should
not be able to execute the \texttt{ListTest} without a test class
corresponding to one of List's subclasses. \texttt{ListTest} contains
all the common tests of \texttt{ArrayListTest} and
\texttt{LinkedListTest}. \texttt{ArrayListTest} and
\texttt{LinkedListTest} can contain their specific tests.

In the example, one can see that the hierarchy of the test classes is
similar to the hierarchy of the classes they test. Therefore, we say
that we use a \textbf{parallel class hierarchy} in our test classes.

Implementation-wise, how do we make sure that the ``super test class''
executes its tests in the correct subclass? This depends on the test
class that is executed and the subclass it is testing. If we have class
\texttt{T}, with subclasses \texttt{A} and \texttt{B}, then when
executing tests for \texttt{A} we need the test class of \texttt{T} to
use an instance of \texttt{A}; when executing tests for \texttt{B}, we
need the test class of \texttt{T} to use an instance of \texttt{B}.

One way to achieve this behaviour is by using the \emph{Factory Method}
design pattern, which works as follows: In the test class for the
interface level (the ``super test class''), we define an abstract method
that returns an instance with the interface type. By making the method
abstract, we force the test classes of the concrete implementations to
override it. We return the instance of the specific subclass in the
overridden method. This instance is then used to execute the tests.

We want to use the Factory Method design pattern in our tests for the
\texttt{List}. We start by the interface level test class. Here, we
define the abstract method that gives us a List.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ ListTest \{}

  \KeywordTok{protected} \DataTypeTok{final} \BuiltInTok{List}\NormalTok{ list = }\FunctionTok{createList}\NormalTok{();}

  \KeywordTok{protected} \KeywordTok{abstract} \BuiltInTok{List} \FunctionTok{createList}\NormalTok{();}

  \CommentTok{// Common List tests using list}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Then, for this example, we create a class to test the
\texttt{ArrayList}. We have to override the \texttt{createList} method
and we can define any tests specific for the \texttt{ArrayList}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ ArrayListTest }\KeywordTok{extends}\NormalTok{ ListTest \{}

  \AttributeTok{@Override}
  \KeywordTok{protected} \BuiltInTok{List} \FunctionTok{createList}\NormalTok{() \{}
    \KeywordTok{return} \KeywordTok{new} \BuiltInTok{ArrayList}\NormalTok{();}
\NormalTok{  \}}

  \CommentTok{// Tests specific for the ArrayList}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now, the \texttt{ArrayListTest} inherits all the \texttt{ListTest}'s
tests, so these will be executed when we execute the
\texttt{ArrayListTest} test suite. Because the \texttt{createList()}
method returns an \texttt{ArrayList}, the common test classes will use
an \texttt{ArrayList}.

\{\% set video\_id = ``GQ5NTiigkb0'' \%\} \{\% include
``/includes/youtube.md'' \%\}

\hypertarget{exercises}{%
\subsection{Exercises}\label{exercises}}

\textbf{Exercise 1.} See the code below:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public}\NormalTok{ Square }\FunctionTok{squareAt}\NormalTok{(}\DataTypeTok{int}\NormalTok{ x, }\DataTypeTok{int}\NormalTok{ y) \{}
\NormalTok{  assert x \textgreater{}= }\DecValTok{0}\NormalTok{;}
\NormalTok{  assert x \textless{} board.}\FunctionTok{length}\NormalTok{;}
\NormalTok{  assert y \textgreater{}= }\DecValTok{0}\NormalTok{;}
\NormalTok{  assert y \textless{} board[x].}\FunctionTok{length}\NormalTok{;}
\NormalTok{  assert board != }\KeywordTok{null}\NormalTok{;}

\NormalTok{  Square result = board[x][y];}

\NormalTok{  assert result != }\KeywordTok{null}\NormalTok{;}
  \KeywordTok{return}\NormalTok{ result;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

What assertion(s), if any, can be turned into a class invariant?

\textbf{Exercise 2.} Consider the piece of code in the previous example.
Suppose we remove the last assertion (line 10), which states that the
result can never be null.

Are the existing pre-conditions of the \texttt{squareAt} method enough
to ensure the property in the original line 10? What can we add to the
class (other than the just removed post-condition) to guarantee this
property?

\textbf{Exercise 3.} Your colleague works on a drawing application. He
has created a Rectangle class. For rectangles, the width and height can
be different from each other, but can't be negative numbers.

Your colleague also defines the Square class. Squares are a special type
of rectangle: the width and height should be equal and also can't be
negative. Your colleague decides to implement this by making Square
inherit from Rectangle.

The code for the two classes is the following.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \BuiltInTok{Rectangle}\NormalTok{ \{}
  \KeywordTok{protected} \DataTypeTok{int}\NormalTok{ width;}
  \KeywordTok{protected} \DataTypeTok{int}\NormalTok{ height;}

  \KeywordTok{protected} \DataTypeTok{boolean} \FunctionTok{invariant}\NormalTok{() \{ }\KeywordTok{return}\NormalTok{ width \textgreater{} }\DecValTok{0}\NormalTok{ \&\& height \textgreater{} }\DecValTok{0}\NormalTok{; \}}

  \KeywordTok{public} \BuiltInTok{Rectangle}\NormalTok{(}\DataTypeTok{int}\NormalTok{ width, }\DataTypeTok{int}\NormalTok{ height) \{}
\NormalTok{    assert width \textgreater{} }\DecValTok{0}\NormalTok{;}
\NormalTok{    assert height \textgreater{} }\DecValTok{0}\NormalTok{;}
    \KeywordTok{this}\NormalTok{.}\FunctionTok{width}\NormalTok{ = width;}
    \KeywordTok{this}\NormalTok{.}\FunctionTok{height}\NormalTok{ = height;}
\NormalTok{    assert }\FunctionTok{invariant}\NormalTok{()}
\NormalTok{  \}}

  \KeywordTok{public} \DataTypeTok{int} \FunctionTok{area}\NormalTok{() \{}
\NormalTok{    assert }\FunctionTok{invariant}\NormalTok{();}
    \DataTypeTok{int}\NormalTok{ a = width * height;}
\NormalTok{    assert a \textgreater{} }\DecValTok{0}\NormalTok{;}
    \KeywordTok{return}\NormalTok{ a;}
\NormalTok{  \}}

  \KeywordTok{public} \DataTypeTok{void} \FunctionTok{resetSize}\NormalTok{(}\DataTypeTok{int}\NormalTok{ width, }\DataTypeTok{int}\NormalTok{ height) \{}
\NormalTok{    assert width \textgreater{} }\DecValTok{0}\NormalTok{;}
\NormalTok{    assert height \textgreater{} }\DecValTok{0}\NormalTok{;}
    \KeywordTok{this}\NormalTok{.}\FunctionTok{width}\NormalTok{ = width;}
    \KeywordTok{this}\NormalTok{.}\FunctionTok{height}\NormalTok{ = height;}
\NormalTok{    assert }\FunctionTok{invariant}\NormalTok{();}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{class}\NormalTok{ Square }\KeywordTok{extends} \BuiltInTok{Rectangle}\NormalTok{ \{}
  \KeywordTok{public} \FunctionTok{Square}\NormalTok{(}\DataTypeTok{int}\NormalTok{ x) \{}
\NormalTok{    assert x \textgreater{} }\DecValTok{0}\NormalTok{;}
    \KeywordTok{super}\NormalTok{(x, x);}
\NormalTok{  \}}

  \AttributeTok{@Override}
  \KeywordTok{public} \DataTypeTok{void} \FunctionTok{resetSize}\NormalTok{(}\DataTypeTok{int}\NormalTok{ width, }\DataTypeTok{int}\NormalTok{ height) \{}
\NormalTok{    assert width == height;}
\NormalTok{    assert width \textgreater{} }\DecValTok{0}\NormalTok{;}
    \KeywordTok{super}\NormalTok{.}\FunctionTok{resetSize}\NormalTok{(width, height);}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Inspired by Bertrand Meyer's design by contracts, he also uses asserts
to make sure contracts are followed. He explicitly defines
pre-conditions and post-conditions in various methods of the base
Rectangle class and the derived Square class.

A second colleague comes in and expresses concerns about the design. How
can you use the assertions provided to discuss the correctness of this
design?

Is the second colleague's concern justified? What principle is violated,
if any? Explain with the assertions shown in the code.

\textbf{Exercise 4.} You run your application with assertion checking
enabled. Unfortunately, it reports an assertion failure signalling a
class invariant violation in one of the libraries your application makes
use of.

Assume that the contract of the library in question is correct, and that
all relevant pre-conditions are encoded in assertions as well.

Can you fix this problem? If so, how? If not, why?

\textbf{Exercise 5.} HTTP requests return a status code which can have
several values. As explained on
\href{https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}{Wikipedia}:

\begin{itemize}
\tightlist
\item
  A 4xx status code ``is intended for situations in which the error
  seems to have been caused by the client''. A well known example is the
  404 (Page not found) status code.
\item
  A 5xx status code ``indicates cases in which the server is aware that
  it has encountered an error or is otherwise incapable of performing
  the request.'' A well known example is the 500 (Internal Server Error)
  status code.
\end{itemize}

What is the best correspondence between these status codes and pre- and
post-conditions?

\textbf{Exercise 6.} A method M belongs to a class C and has a
pre-condition P and a post-condition Q. Now, suppose that a developer
creates a class C' that extends C, and creates a method M' that
overrides M. Which one of the following statements correctly explains
the relative strength of the pre (P') and post-conditions (Q') of the
overridden method M'?

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  P' should be equal or weaker than P, and Q' should be equal or
  stronger than Q.
\item
  P' should be equal or stronger than P, and Q' should be equal or
  stronger than Q.
\item
  P' should be equal or weaker than P, and Q' should be equal or weaker
  than Q.
\item
  P' should be equal or stronger than P, and Q' should be equal or
  weaker than Q.
\end{enumerate}

\textbf{Exercise 7.} Which of the following is a valid reason to use
assertions in your code?

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  To verify expressions with side effects.
\item
  To handle exceptional cases in the program.
\item
  To conduct user input validation.
\item
  To make debugging easier.
\end{enumerate}

\textbf{Exercise 8.} Can static methods have invariants? Explain.

\hypertarget{references}{%
\subsection{References}\label{references}}

\begin{itemize}
\item
  C2 Wiki, What are assertions? http://wiki.c2.com/?WhatAreAssertions
\item
  Mitchell, R., McKim, J., \& Meyer, B. (2001). Design by contract, by
  example. Addison Wesley Longman Publishing Co., Inc..
\item
  Meyer, B. (2002). Design by contract. Prentice Hall.
\item
  Liskov, B. H., \& Wing, J. M. (1994). A behavioural notion of
  subtyping. ACM Transactions on Programming Languages and Systems
  (TOPLAS), 16(6), 1811-1841.
\item
  ``Polymorphic Server Test'' in Binder, R. V. (1994). Object-oriented
  software testing. Communications of the ACM, 37(9), 28-30.
\item
  Regehr, John. Use of Assertions. https://blog.regehr.org/archives/1091
\end{itemize}
