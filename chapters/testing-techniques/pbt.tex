\hypertarget{property-based-testing}{%
\section{Property-Based Testing}\label{property-based-testing}}

We briefly mentioned property checks when talking about
design-by-contracts. There, we used properties in assertions. We can
also use properties for test case generation instead of just assertions.

Given that these properties should always hold, we can test them with
any input that we like. We typically make use of a generator to try a
large number of different inputs, without the need of writing them all
ourselves.

These generators often create a series of random input values for a test
function. The test function then checks if the property holds using an
assertion. For each of the generated input values, this assertion is
checked. If we find an input value that makes the assertion to fail, we
can affirm that the property does not hold.

The first implementation of this idea was called \emph{QuickCheck} and
was originally developed for Haskell. Nowadays, most languages have an
implementation of quick check, including Java. The Java implementation
we are going to use is \href{https://jqwik.net}{jqwik}.

\{\% hint style=`tip' \%\} Jqwik has several features to better support
property-based tests. In this chapter, we only skim through some of
them. We recommend readers to dive into jqwik's manual. \{\% endhint
\%\}

\hypertarget{getting-started-with-property-based-tests}{%
\subsection{Getting started with property-based
tests}\label{getting-started-with-property-based-tests}}

How does it work?

\begin{itemize}
\item
  First, we define properties. Similar to defining test methods, we use
  an annotation on a method with an assertion to define a property:
  \texttt{@Property}. QuickCheck includes a number of generators for
  various types. For example, Strings, Integers, Lists, Dates, etc.
\item
  To generate values, we add some parameters to the annotated method.
  The arguments for these parameters will then be automatically
  generated by jqwik. Note that the existing generators are often not
  enough when we want to test one of our own classes; in these cases, we
  can create a custom generator which generates random values for this
  class.
\item
  jqwik handles the number of generated inputs. After all, generating
  random values for the test input is tricky: the generator might create
  too much data to efficiently handle while testing.
\item
  Finally, as soon as jqwik finds a value that breaks the property, it
  starts the shrinking process. Using random input values can result in
  very large inputs. For example, lists that are very long or strings
  with a lot of characters. These inputs can be very hard to debug.
  Smaller inputs are preferable when it comes to testing. When an input
  makes a property fail, jqwik tries to find a shrunken version of this
  input that still makes the property fail. That way it gets the
  smallest part of a larger input that actually causes the problem.
\end{itemize}

As an example: a property of Strings is that if we add two strings
together, the length of the result should be the same as the sum of the
lengths of the two strings summed. We can use property-based testing and
jqwik's implementation to make tests for this property.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ PropertyTest \{}

  \AttributeTok{@Property}
  \DataTypeTok{void} \FunctionTok{concatenationLength}\NormalTok{(}\AttributeTok{@ForAll} \BuiltInTok{String}\NormalTok{ s1, }\AttributeTok{@ForAll} \BuiltInTok{String}\NormalTok{ s2) \{}
    \BuiltInTok{String}\NormalTok{ s3 = s1 + s2;}

\NormalTok{    Assertions.}\FunctionTok{assertEquals}\NormalTok{(s1.}\FunctionTok{length}\NormalTok{() + s2.}\FunctionTok{length}\NormalTok{(), s3.}\FunctionTok{length}\NormalTok{());}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{concatenationLength} had the \texttt{Property} annotation, so
QuickCheck will generate random values for \texttt{s1} and \texttt{s2}
and execute the test with those values.

Property-based testing changes the way we automate our tests. We have
only been automating the execution of our tests; the design and
instantiation of test cases were always done by us, testers. With
property-based testing, by means of QuickCheck's implementation, we also
automatically generate the inputs of the tests.

\{\% set video\_id = ``7kB6JaSH9p8'' \%\} \{\% include
``/includes/youtube.md'' \%\}

\{\% hint style=`tip' \%\} Note that, in the video, we still use the
\texttt{@RunWith} annotation that was required in JUnit 4 (back then, we
also used the \emph{QuickCheck} framework, and not \emph{jqwik}. The
code in this chapter was updated to \emph{jqwik}, which natively
supports JUnit 5. Nevertheless, the underlying idea is still the same.
\{\% endhint \%\}

\hypertarget{other-examples}{%
\subsection{Other examples}\label{other-examples}}

Suppose the following requirement:

\begin{quote}
Requirement: Passing grade

A student passes an exam if s/he gets a grade \textgreater= 5.0. Grades
below that are a fail.

Grades range from {[}1.0, 10.0{]}.
\end{quote}

We can identify two valid classes and one invalid class in the
requirement: passing grades and non-passing grades, and grades outside
the range.

When doing property-based testing, we declare these properties in form
of jqwik's properties:

\begin{itemize}
\tightlist
\item
  The \texttt{fail} property: for all floats, ranging from 1 (inclusive)
  to 5.0 (exclusive), the program should return false.
\item
  The \texttt{pass} property: for all floats, ranging from 5 (inclusive)
  to 10 (inclusive), the program should return true.
\item
  The \texttt{invalid} property: for all invalid grades (which we define
  as any number below 0.9 or greater than 10.1), the program must throw
  an exception.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ PassingGradesPBTest \{}

    \KeywordTok{private} \DataTypeTok{final}\NormalTok{ PassingGrade pg = }\KeywordTok{new} \FunctionTok{PassingGrade}\NormalTok{();}

    \AttributeTok{@Property}
    \DataTypeTok{void} \FunctionTok{fail}\NormalTok{(}\AttributeTok{@ForAll} \AttributeTok{@FloatRange}\NormalTok{(min = }\FloatTok{1f}\NormalTok{, max = }\FloatTok{5.0f}\NormalTok{, maxIncluded = }\KeywordTok{false}\NormalTok{) }\DataTypeTok{float}\NormalTok{ grade) \{}
        \FunctionTok{assertThat}\NormalTok{(pg.}\FunctionTok{passed}\NormalTok{(grade)).}\FunctionTok{isFalse}\NormalTok{();}
\NormalTok{    \}}

    \AttributeTok{@Property}
    \DataTypeTok{void} \FunctionTok{pass}\NormalTok{(}\AttributeTok{@ForAll} \AttributeTok{@FloatRange}\NormalTok{(min = }\FloatTok{5.0f}\NormalTok{, max = }\FloatTok{10.0f}\NormalTok{, maxIncluded = }\KeywordTok{true}\NormalTok{) }\DataTypeTok{float}\NormalTok{ grade) \{}
        \FunctionTok{assertThat}\NormalTok{(pg.}\FunctionTok{passed}\NormalTok{(grade)).}\FunctionTok{isTrue}\NormalTok{();}
\NormalTok{    \}}

    \AttributeTok{@Property}
    \DataTypeTok{void} \FunctionTok{invalid}\NormalTok{(}\AttributeTok{@ForAll}\NormalTok{(}\StringTok{"invalidGrades"}\NormalTok{) }\DataTypeTok{float}\NormalTok{ grade) \{}
        \FunctionTok{assertThatThrownBy}\NormalTok{(() {-}\textgreater{} \{}
\NormalTok{            pg.}\FunctionTok{passed}\NormalTok{(grade);}
\NormalTok{        \})}
\NormalTok{        .}\FunctionTok{isInstanceOf}\NormalTok{(}\BuiltInTok{IllegalArgumentException}\NormalTok{.}\FunctionTok{class}\NormalTok{);}
\NormalTok{    \}}

    \AttributeTok{@Provide}
    \KeywordTok{private}\NormalTok{ Arbitrary\textless{}}\BuiltInTok{Float}\NormalTok{\textgreater{} }\FunctionTok{invalidGrades}\NormalTok{() \{}
        \KeywordTok{return}\NormalTok{ Arbitraries.}\FunctionTok{oneOf}\NormalTok{(}
\NormalTok{                Arbitraries.}\FunctionTok{floats}\NormalTok{().}\FunctionTok{lessOrEqual}\NormalTok{(}\FloatTok{0.9f}\NormalTok{),}
\NormalTok{                Arbitraries.}\FunctionTok{floats}\NormalTok{().}\FunctionTok{greaterOrEqual}\NormalTok{(}\FloatTok{10.1f}\NormalTok{));}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

See another requirement, also used as an example in jqwik's website:

\begin{quote}
Requirement: FizzBuzz

The program must return `Fizz' to multiples of 3, `Buzz' to multiples of
5, and `FizzBuzz' to multiples of 3 and 5. The program must throw an
exception for numbers below 0 (inclusive).
\end{quote}

We can derive four clear properties:

\begin{itemize}
\tightlist
\item
  Property \texttt{fizz}: for all numbers divisible by 3, and not
  divisible by 5, the program returns ``Fizz'' (see the
  \texttt{divisibleBy3} provider method to understand how we feed values
  with such properties).
\item
  Property \texttt{buzz}: for all numbers divisible by 5 (and not
  divisible by 3), the program returns ``Buzz''.
\item
  Property \texttt{fizzbuzz}: for all numbers divisible by 3 and 5, the
  program returns ``FizzBuzz''.
\item
  Property \texttt{noZeroesAndNegatives}: the program throws an
  exception for all numbers that are zero or smaller.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ FizzBuzzTest \{}

    \KeywordTok{private} \DataTypeTok{final}\NormalTok{ FizzBuzz fb = }\KeywordTok{new} \FunctionTok{FizzBuzz}\NormalTok{();}

    \AttributeTok{@Property}
    \DataTypeTok{boolean} \FunctionTok{fizz}\NormalTok{(}\AttributeTok{@ForAll}\NormalTok{(}\StringTok{"divisibleBy3"}\NormalTok{) }\DataTypeTok{int}\NormalTok{ i) \{}
        \KeywordTok{return}\NormalTok{ fb.}\FunctionTok{fizzbuzz}\NormalTok{(i).}\FunctionTok{equals}\NormalTok{(}\StringTok{"Fizz"}\NormalTok{);}
\NormalTok{    \}}

    \AttributeTok{@Property}
    \DataTypeTok{boolean} \FunctionTok{buzz}\NormalTok{(}\AttributeTok{@ForAll}\NormalTok{(}\StringTok{"divisibleBy5"}\NormalTok{) }\DataTypeTok{int}\NormalTok{ i) \{}
        \KeywordTok{return}\NormalTok{ fb.}\FunctionTok{fizzbuzz}\NormalTok{(i).}\FunctionTok{equals}\NormalTok{(}\StringTok{"Buzz"}\NormalTok{);}
\NormalTok{    \}}

    \AttributeTok{@Property}
    \DataTypeTok{boolean} \FunctionTok{fizzbuzz}\NormalTok{(}\AttributeTok{@ForAll}\NormalTok{(}\StringTok{"divisibleBy3and5"}\NormalTok{) }\DataTypeTok{int}\NormalTok{ i) \{}
        \KeywordTok{return}\NormalTok{ fb.}\FunctionTok{fizzbuzz}\NormalTok{(i).}\FunctionTok{equals}\NormalTok{(}\StringTok{"FizzBuzz"}\NormalTok{);}
\NormalTok{    \}}

    \AttributeTok{@Property}
    \DataTypeTok{void} \FunctionTok{noZeroesAndNegatives}\NormalTok{(}\AttributeTok{@ForAll}\NormalTok{(}\StringTok{"negative"}\NormalTok{) }\DataTypeTok{int}\NormalTok{ i) \{}
        \FunctionTok{assertThrows}\NormalTok{(}\BuiltInTok{IllegalArgumentException}\NormalTok{.}\FunctionTok{class}\NormalTok{, () {-}\textgreater{} fb.}\FunctionTok{fizzbuzz}\NormalTok{(i).}\FunctionTok{equals}\NormalTok{(}\StringTok{"FizzBuzz"}\NormalTok{));}
\NormalTok{    \}}

    \AttributeTok{@Provide}
\NormalTok{    Arbitrary\textless{}}\BuiltInTok{Integer}\NormalTok{\textgreater{} }\FunctionTok{divisibleBy3}\NormalTok{() \{}
        \KeywordTok{return}\NormalTok{ Arbitraries.}\FunctionTok{integers}\NormalTok{()}
\NormalTok{                .}\FunctionTok{greaterOrEqual}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{                .}\FunctionTok{filter}\NormalTok{(i {-}\textgreater{} i \% }\DecValTok{3}\NormalTok{ == }\DecValTok{0}\NormalTok{)}
\NormalTok{                .}\FunctionTok{filter}\NormalTok{(i {-}\textgreater{} i \% }\DecValTok{5}\NormalTok{ != }\DecValTok{0}\NormalTok{);}
\NormalTok{    \}}

    \AttributeTok{@Provide}
\NormalTok{    Arbitrary\textless{}}\BuiltInTok{Integer}\NormalTok{\textgreater{} }\FunctionTok{divisibleBy5}\NormalTok{() \{}
        \KeywordTok{return}\NormalTok{ Arbitraries.}\FunctionTok{integers}\NormalTok{()}
\NormalTok{                .}\FunctionTok{greaterOrEqual}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{                .}\FunctionTok{filter}\NormalTok{(i {-}\textgreater{} i \% }\DecValTok{5}\NormalTok{ == }\DecValTok{0}\NormalTok{)}
\NormalTok{                .}\FunctionTok{filter}\NormalTok{(i {-}\textgreater{} i \% }\DecValTok{3}\NormalTok{ != }\DecValTok{0}\NormalTok{);}
\NormalTok{    \}}

    \AttributeTok{@Provide}
\NormalTok{    Arbitrary\textless{}}\BuiltInTok{Integer}\NormalTok{\textgreater{} }\FunctionTok{divisibleBy3and5}\NormalTok{() \{}
        \KeywordTok{return}\NormalTok{ Arbitraries.}\FunctionTok{integers}\NormalTok{()}
\NormalTok{                .}\FunctionTok{greaterOrEqual}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{                .}\FunctionTok{filter}\NormalTok{(i {-}\textgreater{} i \% }\DecValTok{3}\NormalTok{ == }\DecValTok{0}\NormalTok{)}
\NormalTok{                .}\FunctionTok{filter}\NormalTok{(i {-}\textgreater{} i \% }\DecValTok{5}\NormalTok{ == }\DecValTok{0}\NormalTok{);}
\NormalTok{    \}}

    \AttributeTok{@Provide}
\NormalTok{    Arbitrary\textless{}}\BuiltInTok{Integer}\NormalTok{\textgreater{} }\FunctionTok{negative}\NormalTok{() \{}
        \KeywordTok{return}\NormalTok{ Arbitraries.}\FunctionTok{integers}\NormalTok{().}\FunctionTok{lessOrEqual}\NormalTok{(}\DecValTok{0}\NormalTok{);}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You may see other examples in our
\href{https://www.github.com/sttp-book/code-examples}{code repository}.

\hypertarget{exercises}{%
\subsection{Exercises}\label{exercises}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write property-based tests for all the exercises we discussed in the
  domain testing chapters and appendix.
\end{enumerate}
